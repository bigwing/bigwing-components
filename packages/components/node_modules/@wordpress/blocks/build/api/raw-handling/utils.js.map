{"version":3,"sources":["@wordpress/blocks/src/api/raw-handling/utils.js"],"names":["window","Node","ELEMENT_NODE","TEXT_NODE","getBlockContentSchema","transforms","phrasingContentSchema","isPaste","schemas","map","isMatch","blockName","schema","hasAnchorSupport","value","attributes","undefined","mergeWith","objValue","srcValue","key","isEmpty","element","hasChildNodes","Array","from","childNodes","every","node","nodeType","nodeValue","trim","nodeName","hasAttributes","isPlain","HTML","test","deepFilterNodeList","nodeList","filters","doc","forEach","item","contains","deepFilterHTML","document","implementation","createHTMLDocument","body","innerHTML","cleanNodeList","inline","tag","toLowerCase","hasOwnProperty","classes","children","require","allowEmpty","name","removeAttribute","classList","length","mattchers","className","RegExp","noop","some","remove","querySelector","join","parentNode","child","firstChild","nextElementSibling","createElement","removeInvalidHTML","getSibling","which","sibling"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { mapValues, mergeWith, includes, noop, isFunction } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { unwrap, insertAfter, remove } from '@wordpress/dom';\n\n/**\n * Internal dependencies\n */\nimport { hasBlockSupport } from '..';\nimport { isPhrasingContent } from './phrasing-content';\n\n/**\n * Browser dependencies\n */\nconst { ELEMENT_NODE, TEXT_NODE } = window.Node;\n\n/**\n * Given raw transforms from blocks, merges all schemas into one.\n *\n * @param {Array}  transforms            Block transforms, of the `raw` type.\n * @param {Object} phrasingContentSchema The phrasing content schema.\n * @param {Object} isPaste               Whether the context is pasting or not.\n *\n * @return {Object} A complete block content schema.\n */\nexport function getBlockContentSchema(\n\ttransforms,\n\tphrasingContentSchema,\n\tisPaste\n) {\n\tconst schemas = transforms.map( ( { isMatch, blockName, schema } ) => {\n\t\tconst hasAnchorSupport = hasBlockSupport( blockName, 'anchor' );\n\n\t\tschema = isFunction( schema )\n\t\t\t? schema( { phrasingContentSchema, isPaste } )\n\t\t\t: schema;\n\n\t\t// If the block does not has anchor support and the transform does not\n\t\t// provides an isMatch we can return the schema right away.\n\t\tif ( ! hasAnchorSupport && ! isMatch ) {\n\t\t\treturn schema;\n\t\t}\n\n\t\treturn mapValues( schema, ( value ) => {\n\t\t\tlet attributes = value.attributes || [];\n\t\t\t// If the block supports the \"anchor\" functionality, it needs to keep its ID attribute.\n\t\t\tif ( hasAnchorSupport ) {\n\t\t\t\tattributes = [ ...attributes, 'id' ];\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t...value,\n\t\t\t\tattributes,\n\t\t\t\tisMatch: isMatch ? isMatch : undefined,\n\t\t\t};\n\t\t} );\n\t} );\n\n\treturn mergeWith( {}, ...schemas, ( objValue, srcValue, key ) => {\n\t\tswitch ( key ) {\n\t\t\tcase 'children': {\n\t\t\t\tif ( objValue === '*' || srcValue === '*' ) {\n\t\t\t\t\treturn '*';\n\t\t\t\t}\n\n\t\t\t\treturn { ...objValue, ...srcValue };\n\t\t\t}\n\t\t\tcase 'attributes':\n\t\t\tcase 'require': {\n\t\t\t\treturn [ ...( objValue || [] ), ...( srcValue || [] ) ];\n\t\t\t}\n\t\t\tcase 'isMatch': {\n\t\t\t\t// If one of the values being merge is undefined (matches everything),\n\t\t\t\t// the result of the merge will be undefined.\n\t\t\t\tif ( ! objValue || ! srcValue ) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\t// When merging two isMatch functions, the result is a new function\n\t\t\t\t// that returns if one of the source functions returns true.\n\t\t\t\treturn ( ...args ) => {\n\t\t\t\t\treturn objValue( ...args ) || srcValue( ...args );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t} );\n}\n\n/**\n * Recursively checks if an element is empty. An element is not empty if it\n * contains text or contains elements with attributes such as images.\n *\n * @param {Element} element The element to check.\n *\n * @return {boolean} Wether or not the element is empty.\n */\nexport function isEmpty( element ) {\n\tif ( ! element.hasChildNodes() ) {\n\t\treturn true;\n\t}\n\n\treturn Array.from( element.childNodes ).every( ( node ) => {\n\t\tif ( node.nodeType === TEXT_NODE ) {\n\t\t\treturn ! node.nodeValue.trim();\n\t\t}\n\n\t\tif ( node.nodeType === ELEMENT_NODE ) {\n\t\t\tif ( node.nodeName === 'BR' ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( node.hasAttributes() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEmpty( node );\n\t\t}\n\n\t\treturn true;\n\t} );\n}\n\n/**\n * Checks wether HTML can be considered plain text. That is, it does not contain\n * any elements that are not line breaks.\n *\n * @param {string} HTML The HTML to check.\n *\n * @return {boolean} Wether the HTML can be considered plain text.\n */\nexport function isPlain( HTML ) {\n\treturn ! /<(?!br[ />])/i.test( HTML );\n}\n\n/**\n * Given node filters, deeply filters and mutates a NodeList.\n *\n * @param {NodeList} nodeList The nodeList to filter.\n * @param {Array}    filters  An array of functions that can mutate with the provided node.\n * @param {Document} doc      The document of the nodeList.\n * @param {Object}   schema   The schema to use.\n */\nexport function deepFilterNodeList( nodeList, filters, doc, schema ) {\n\tArray.from( nodeList ).forEach( ( node ) => {\n\t\tdeepFilterNodeList( node.childNodes, filters, doc, schema );\n\n\t\tfilters.forEach( ( item ) => {\n\t\t\t// Make sure the node is still attached to the document.\n\t\t\tif ( ! doc.contains( node ) ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\titem( node, doc, schema );\n\t\t} );\n\t} );\n}\n\n/**\n * Given node filters, deeply filters HTML tags.\n * Filters from the deepest nodes to the top.\n *\n * @param {string} HTML    The HTML to filter.\n * @param {Array}  filters An array of functions that can mutate with the provided node.\n * @param {Object} schema  The schema to use.\n *\n * @return {string} The filtered HTML.\n */\nexport function deepFilterHTML( HTML, filters = [], schema ) {\n\tconst doc = document.implementation.createHTMLDocument( '' );\n\n\tdoc.body.innerHTML = HTML;\n\n\tdeepFilterNodeList( doc.body.childNodes, filters, doc, schema );\n\n\treturn doc.body.innerHTML;\n}\n\n/**\n * Given a schema, unwraps or removes nodes, attributes and classes on a node\n * list.\n *\n * @param {NodeList} nodeList The nodeList to filter.\n * @param {Document} doc      The document of the nodeList.\n * @param {Object}   schema   An array of functions that can mutate with the provided node.\n * @param {Object}   inline   Whether to clean for inline mode.\n */\nfunction cleanNodeList( nodeList, doc, schema, inline ) {\n\tArray.from( nodeList ).forEach( ( node ) => {\n\t\tconst tag = node.nodeName.toLowerCase();\n\n\t\t// It's a valid child, if the tag exists in the schema without an isMatch\n\t\t// function, or with an isMatch function that matches the node.\n\t\tif (\n\t\t\tschema.hasOwnProperty( tag ) &&\n\t\t\t( ! schema[ tag ].isMatch || schema[ tag ].isMatch( node ) )\n\t\t) {\n\t\t\tif ( node.nodeType === ELEMENT_NODE ) {\n\t\t\t\tconst {\n\t\t\t\t\tattributes = [],\n\t\t\t\t\tclasses = [],\n\t\t\t\t\tchildren,\n\t\t\t\t\trequire = [],\n\t\t\t\t\tallowEmpty,\n\t\t\t\t} = schema[ tag ];\n\n\t\t\t\t// If the node is empty and it's supposed to have children,\n\t\t\t\t// remove the node.\n\t\t\t\tif ( children && ! allowEmpty && isEmpty( node ) ) {\n\t\t\t\t\tremove( node );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( node.hasAttributes() ) {\n\t\t\t\t\t// Strip invalid attributes.\n\t\t\t\t\tArray.from( node.attributes ).forEach( ( { name } ) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tname !== 'class' &&\n\t\t\t\t\t\t\t! includes( attributes, name )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnode.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Strip invalid classes.\n\t\t\t\t\t// In jsdom-jscore, 'node.classList' can be undefined.\n\t\t\t\t\t// TODO: Explore patching this in jsdom-jscore.\n\t\t\t\t\tif ( node.classList && node.classList.length ) {\n\t\t\t\t\t\tconst mattchers = classes.map( ( item ) => {\n\t\t\t\t\t\t\tif ( typeof item === 'string' ) {\n\t\t\t\t\t\t\t\treturn ( className ) => className === item;\n\t\t\t\t\t\t\t} else if ( item instanceof RegExp ) {\n\t\t\t\t\t\t\t\treturn ( className ) => item.test( className );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn noop;\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tArray.from( node.classList ).forEach( ( name ) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t! mattchers.some( ( isMatch ) =>\n\t\t\t\t\t\t\t\t\tisMatch( name )\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tnode.classList.remove( name );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tif ( ! node.classList.length ) {\n\t\t\t\t\t\t\tnode.removeAttribute( 'class' );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( node.hasChildNodes() ) {\n\t\t\t\t\t// Do not filter any content.\n\t\t\t\t\tif ( children === '*' ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Continue if the node is supposed to have children.\n\t\t\t\t\tif ( children ) {\n\t\t\t\t\t\t// If a parent requires certain children, but it does\n\t\t\t\t\t\t// not have them, drop the parent and continue.\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\trequire.length &&\n\t\t\t\t\t\t\t! node.querySelector( require.join( ',' ) )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t// If the node is at the top, phrasing content, and\n\t\t\t\t\t\t\t// contains children that are block content, unwrap\n\t\t\t\t\t\t\t// the node because it is invalid.\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tnode.parentNode.nodeName === 'BODY' &&\n\t\t\t\t\t\t\tisPhrasingContent( node )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tArray.from( node.childNodes ).some(\n\t\t\t\t\t\t\t\t\t( child ) => ! isPhrasingContent( child )\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tunwrap( node );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcleanNodeList(\n\t\t\t\t\t\t\t\tnode.childNodes,\n\t\t\t\t\t\t\t\tdoc,\n\t\t\t\t\t\t\t\tchildren,\n\t\t\t\t\t\t\t\tinline\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Remove children if the node is not supposed to have any.\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile ( node.firstChild ) {\n\t\t\t\t\t\t\tremove( node.firstChild );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Invalid child. Continue with schema at the same place and unwrap.\n\t\t} else {\n\t\t\tcleanNodeList( node.childNodes, doc, schema, inline );\n\n\t\t\t// For inline mode, insert a line break when unwrapping nodes that\n\t\t\t// are not phrasing content.\n\t\t\tif (\n\t\t\t\tinline &&\n\t\t\t\t! isPhrasingContent( node ) &&\n\t\t\t\tnode.nextElementSibling\n\t\t\t) {\n\t\t\t\tinsertAfter( doc.createElement( 'br' ), node );\n\t\t\t}\n\n\t\t\tunwrap( node );\n\t\t}\n\t} );\n}\n\n/**\n * Given a schema, unwraps or removes nodes, attributes and classes on HTML.\n *\n * @param {string} HTML   The HTML to clean up.\n * @param {Object} schema Schema for the HTML.\n * @param {Object} inline Whether to clean for inline mode.\n *\n * @return {string} The cleaned up HTML.\n */\nexport function removeInvalidHTML( HTML, schema, inline ) {\n\tconst doc = document.implementation.createHTMLDocument( '' );\n\n\tdoc.body.innerHTML = HTML;\n\n\tcleanNodeList( doc.body.childNodes, doc, schema, inline );\n\n\treturn doc.body.innerHTML;\n}\n\n/**\n * Gets a sibling within text-level context.\n *\n * @param {Element} node  The subject node.\n * @param {string}  which \"next\" or \"previous\".\n */\nexport function getSibling( node, which ) {\n\tconst sibling = node[ `${ which }Sibling` ];\n\n\tif ( sibling && isPhrasingContent( sibling ) ) {\n\t\treturn sibling;\n\t}\n\n\tconst { parentNode } = node;\n\n\tif ( ! parentNode || ! isPhrasingContent( parentNode ) ) {\n\t\treturn;\n\t}\n\n\treturn getSibling( parentNode, which );\n}\n"]}