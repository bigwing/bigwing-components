{"version":3,"sources":["@wordpress/rich-text/src/to-tree.js"],"names":["fromFormat","type","attributes","unregisteredAttributes","object","boundaryClass","formatType","elementAttributes","name","key","className","class","tagName","isEqualUntil","a","b","index","toTree","value","multilineTag","preserveWhiteSpace","createEmpty","append","getLastChild","getParent","isText","getText","remove","appendText","onStartIndex","onEndIndex","isEditableTree","placeholder","formats","replacements","text","start","end","formatsLength","length","tree","multilineFormat","activeFormats","deepestActiveFormat","lastSeparatorFormats","lastCharacterFormats","lastCharacter","i","character","charAt","shouldInsertPadding","LINE_SEPARATOR","characterFormats","reduce","accumulator","format","push","pointer","node","ZWNBSP","forEach","formatIndex","parent","newNode","OBJECT_REPLACEMENT_CHARACTER","undefined","contenteditable"],"mappings":"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","sourcesContent":["/**\n * Internal dependencies\n */\n\nimport { getActiveFormats } from './get-active-formats';\nimport { getFormatType } from './get-format-type';\nimport {\n\tLINE_SEPARATOR,\n\tOBJECT_REPLACEMENT_CHARACTER,\n\tZWNBSP,\n} from './special-characters';\n\n/**\n * Converts a format object to information that can be used to create an element\n * from (type, attributes and object).\n *\n * @param  {Object}  $1                        Named parameters.\n * @param  {string}  $1.type                   The format type.\n * @param  {Object}  $1.attributes             The format attributes.\n * @param  {Object}  $1.unregisteredAttributes The unregistered format\n *                                             attributes.\n * @param  {boolean} $1.object                 Wether or not it is an object\n *                                             format.\n * @param  {boolean} $1.boundaryClass          Wether or not to apply a boundary\n *                                             class.\n * @return {Object}                            Information to be used for\n *                                             element creation.\n */\nfunction fromFormat( {\n\ttype,\n\tattributes,\n\tunregisteredAttributes,\n\tobject,\n\tboundaryClass,\n} ) {\n\tconst formatType = getFormatType( type );\n\n\tlet elementAttributes = {};\n\n\tif ( boundaryClass ) {\n\t\telementAttributes[ 'data-rich-text-format-boundary' ] = 'true';\n\t}\n\n\tif ( ! formatType ) {\n\t\tif ( attributes ) {\n\t\t\telementAttributes = { ...attributes, ...elementAttributes };\n\t\t}\n\n\t\treturn { type, attributes: elementAttributes, object };\n\t}\n\n\telementAttributes = { ...unregisteredAttributes, ...elementAttributes };\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes\n\t\t\t? formatType.attributes[ name ]\n\t\t\t: false;\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\tif ( formatType.className ) {\n\t\tif ( elementAttributes.class ) {\n\t\t\telementAttributes.class = `${ formatType.className } ${ elementAttributes.class }`;\n\t\t} else {\n\t\t\telementAttributes.class = formatType.className;\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: formatType.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: elementAttributes,\n\t};\n}\n\n/**\n * Checks if both arrays of formats up until a certain index are equal.\n *\n * @param {Array}  a     Array of formats to compare.\n * @param {Array}  b     Array of formats to compare.\n * @param {number} index Index to check until.\n */\nfunction isEqualUntil( a, b, index ) {\n\tdo {\n\t\tif ( a[ index ] !== b[ index ] ) {\n\t\t\treturn false;\n\t\t}\n\t} while ( index-- );\n\n\treturn true;\n}\n\nexport function toTree( {\n\tvalue,\n\tmultilineTag,\n\tpreserveWhiteSpace,\n\tcreateEmpty,\n\tappend,\n\tgetLastChild,\n\tgetParent,\n\tisText,\n\tgetText,\n\tremove,\n\tappendText,\n\tonStartIndex,\n\tonEndIndex,\n\tisEditableTree,\n\tplaceholder,\n} ) {\n\tconst { formats, replacements, text, start, end } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty();\n\tconst multilineFormat = { type: multilineTag };\n\tconst activeFormats = getActiveFormats( value );\n\tconst deepestActiveFormat = activeFormats[ activeFormats.length - 1 ];\n\n\tlet lastSeparatorFormats;\n\tlet lastCharacterFormats;\n\tlet lastCharacter;\n\n\t// If we're building a multiline tree, start off with a multiline element.\n\tif ( multilineTag ) {\n\t\tappend( append( tree, { type: multilineTag } ), '' );\n\t\tlastCharacterFormats = lastSeparatorFormats = [ multilineFormat ];\n\t} else {\n\t\tappend( tree, '' );\n\t}\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tconst shouldInsertPadding =\n\t\t\tisEditableTree &&\n\t\t\t// Pad the line if the line is empty.\n\t\t\t( ! lastCharacter ||\n\t\t\t\tlastCharacter === LINE_SEPARATOR ||\n\t\t\t\t// Pad the line if the previous character is a line break, otherwise\n\t\t\t\t// the line break won't be visible.\n\t\t\t\tlastCharacter === '\\n' );\n\n\t\tlet characterFormats = formats[ i ];\n\n\t\t// Set multiline tags in queue for building the tree.\n\t\tif ( multilineTag ) {\n\t\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\t\tcharacterFormats = lastSeparatorFormats = (\n\t\t\t\t\treplacements[ i ] || []\n\t\t\t\t).reduce(\n\t\t\t\t\t( accumulator, format ) => {\n\t\t\t\t\t\taccumulator.push( format, multilineFormat );\n\t\t\t\t\t\treturn accumulator;\n\t\t\t\t\t},\n\t\t\t\t\t[ multilineFormat ]\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tcharacterFormats = [\n\t\t\t\t\t...lastSeparatorFormats,\n\t\t\t\t\t...( characterFormats || [] ),\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\tlet pointer = getLastChild( tree );\n\n\t\tif ( shouldInsertPadding && character === LINE_SEPARATOR ) {\n\t\t\tlet node = pointer;\n\n\t\t\twhile ( ! isText( node ) ) {\n\t\t\t\tnode = getLastChild( node );\n\t\t\t}\n\n\t\t\tappend( getParent( node ), ZWNBSP );\n\t\t}\n\n\t\t// Set selection for the start of line.\n\t\tif ( lastCharacter === LINE_SEPARATOR ) {\n\t\t\tlet node = pointer;\n\n\t\t\twhile ( ! isText( node ) ) {\n\t\t\t\tnode = getLastChild( node );\n\t\t\t}\n\n\t\t\tif ( onStartIndex && start === i ) {\n\t\t\t\tonStartIndex( tree, node );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === i ) {\n\t\t\t\tonEndIndex( tree, node );\n\t\t\t}\n\t\t}\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\t// Reuse the last element if all formats remain the same.\n\t\t\t\t\tisEqualUntil(\n\t\t\t\t\t\tcharacterFormats,\n\t\t\t\t\t\tlastCharacterFormats,\n\t\t\t\t\t\tformatIndex\n\t\t\t\t\t) &&\n\t\t\t\t\t// Do not reuse the last element if the character is a\n\t\t\t\t\t// line separator.\n\t\t\t\t\t( character !== LINE_SEPARATOR ||\n\t\t\t\t\t\tcharacterFormats.length - 1 !== formatIndex )\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { type, attributes, unregisteredAttributes } = format;\n\n\t\t\t\tconst boundaryClass =\n\t\t\t\t\tisEditableTree &&\n\t\t\t\t\tcharacter !== LINE_SEPARATOR &&\n\t\t\t\t\tformat === deepestActiveFormat;\n\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append(\n\t\t\t\t\tparent,\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t\tunregisteredAttributes,\n\t\t\t\t\t\tboundaryClass,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// No need for further processing if the character is a line separator.\n\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\tlastCharacterFormats = characterFormats;\n\t\t\tlastCharacter = character;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\t\tif ( i === 0 ) {\n\t\t\tif ( onStartIndex && start === 0 ) {\n\t\t\t\tonStartIndex( tree, pointer );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === 0 ) {\n\t\t\t\tonEndIndex( tree, pointer );\n\t\t\t}\n\t\t}\n\n\t\tif ( character === OBJECT_REPLACEMENT_CHARACTER ) {\n\t\t\tpointer = append(\n\t\t\t\tgetParent( pointer ),\n\t\t\t\tfromFormat( {\n\t\t\t\t\t...replacements[ i ],\n\t\t\t\t\tobject: true,\n\t\t\t\t} )\n\t\t\t);\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! preserveWhiteSpace && character === '\\n' ) {\n\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\ttype: 'br',\n\t\t\t\tattributes: isEditableTree\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t'data-rich-text-line-break': 'true',\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined,\n\t\t\t\tobject: true,\n\t\t\t} );\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! isText( pointer ) ) {\n\t\t\tpointer = append( getParent( pointer ), character );\n\t\t} else {\n\t\t\tappendText( pointer, character );\n\t\t}\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer );\n\t\t}\n\n\t\tif ( shouldInsertPadding && i === text.length ) {\n\t\t\tappend( getParent( pointer ), ZWNBSP );\n\n\t\t\tif ( placeholder && text.length === 0 ) {\n\t\t\t\tappend( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t'data-rich-text-placeholder': placeholder,\n\t\t\t\t\t\t// Necessary to prevent the placeholder from catching\n\t\t\t\t\t\t// selection. The placeholder is also not editable after\n\t\t\t\t\t\t// all.\n\t\t\t\t\t\tcontenteditable: 'false',\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tlastCharacterFormats = characterFormats;\n\t\tlastCharacter = character;\n\t}\n\n\treturn tree;\n}\n"]}