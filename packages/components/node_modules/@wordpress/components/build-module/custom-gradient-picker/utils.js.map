{"version":3,"sources":["@wordpress/components/src/custom-gradient-picker/utils.js"],"names":["findIndex","map","some","gradientParser","DEFAULT_GRADIENT","INSERT_POINT_WIDTH","MINIMUM_ABSOLUTE_LEFT_POSITION","MINIMUM_DISTANCE_BETWEEN_POINTS","HORIZONTAL_GRADIENT_ORIENTATION","serializeGradientColor","serializeGradientPosition","serializeGradient","tinyColorRgbToGradientColorStop","r","g","b","a","type","value","getGradientWithColorStopAdded","gradientAST","relativePosition","rgbaColor","colorStop","length","colorStops","getGradientWithPositionAtIndexChanged","index","colorStopIndex","isControlPointOverlapping","position","initialIndex","initialPosition","parseInt","minPosition","Math","min","maxPosition","max","itemPosition","abs","getGradientWithPositionAtIndexSummed","valueToSum","currentPosition","newPosition","getGradientWithPositionAtIndexIncreased","getGradientWithPositionAtIndexDecreased","getGradientWithColorAtIndexChanged","getGradientWithColorAtPositionChanged","relativePositionValue","toString","getGradientWithControlPointRemoved","filter","elem","elemIndex","getHorizontalRelativeGradientPosition","mouseXCoordinate","containerElement","positionedElementWidth","getBoundingClientRect","x","width","absolutePositionValue","availableWidth","round","getMarkerPoints","color","positionValue","getLinearGradientRepresentationOfARadial","orientation","DIRECTIONAL_ORIENTATION_ANGLE_MAP","top","right","bottom","left","getGradientParsed","hasGradient","gradientValue","parse","error"],"mappings":"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","sourcesContent":["/**\n * External dependencies\n */\nimport { findIndex, map, some } from 'lodash';\nimport gradientParser from 'gradient-parser';\n\n/**\n * Internal dependencies\n */\nimport {\n\tDEFAULT_GRADIENT,\n\tINSERT_POINT_WIDTH,\n\tMINIMUM_ABSOLUTE_LEFT_POSITION,\n\tMINIMUM_DISTANCE_BETWEEN_POINTS,\n\tHORIZONTAL_GRADIENT_ORIENTATION,\n} from './constants';\nimport {\n\tserializeGradientColor,\n\tserializeGradientPosition,\n\tserializeGradient,\n} from './serializer';\n\nfunction tinyColorRgbToGradientColorStop( { r, g, b, a } ) {\n\tif ( a === 1 ) {\n\t\treturn {\n\t\t\ttype: 'rgb',\n\t\t\tvalue: [ r, g, b ],\n\t\t};\n\t}\n\treturn {\n\t\ttype: 'rgba',\n\t\tvalue: [ r, g, b, a ],\n\t};\n}\n\nexport function getGradientWithColorStopAdded(\n\tgradientAST,\n\trelativePosition,\n\trgbaColor\n) {\n\tconst colorStop = tinyColorRgbToGradientColorStop( rgbaColor );\n\tcolorStop.length = {\n\t\ttype: '%',\n\t\tvalue: relativePosition,\n\t};\n\treturn {\n\t\t...gradientAST,\n\t\tcolorStops: [ ...gradientAST.colorStops, colorStop ],\n\t};\n}\n\nexport function getGradientWithPositionAtIndexChanged(\n\tgradientAST,\n\tindex,\n\trelativePosition\n) {\n\treturn {\n\t\t...gradientAST,\n\t\tcolorStops: gradientAST.colorStops.map(\n\t\t\t( colorStop, colorStopIndex ) => {\n\t\t\t\tif ( colorStopIndex !== index ) {\n\t\t\t\t\treturn colorStop;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\t...colorStop,\n\t\t\t\t\tlength: {\n\t\t\t\t\t\t...colorStop.length,\n\t\t\t\t\t\tvalue: relativePosition,\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t),\n\t};\n}\n\nexport function isControlPointOverlapping(\n\tgradientAST,\n\tposition,\n\tinitialIndex\n) {\n\tconst initialPosition = parseInt(\n\t\tgradientAST.colorStops[ initialIndex ].length.value\n\t);\n\tconst minPosition = Math.min( initialPosition, position );\n\tconst maxPosition = Math.max( initialPosition, position );\n\n\treturn some( gradientAST.colorStops, ( { length }, index ) => {\n\t\tconst itemPosition = parseInt( length.value );\n\t\treturn (\n\t\t\tindex !== initialIndex &&\n\t\t\t( Math.abs( itemPosition - position ) <\n\t\t\t\tMINIMUM_DISTANCE_BETWEEN_POINTS ||\n\t\t\t\t( minPosition < itemPosition && itemPosition < maxPosition ) )\n\t\t);\n\t} );\n}\n\nfunction getGradientWithPositionAtIndexSummed(\n\tgradientAST,\n\tindex,\n\tvalueToSum\n) {\n\tconst currentPosition = gradientAST.colorStops[ index ].length.value;\n\tconst newPosition = Math.max(\n\t\t0,\n\t\tMath.min( 100, parseInt( currentPosition ) + valueToSum )\n\t);\n\tif ( isControlPointOverlapping( gradientAST, newPosition, index ) ) {\n\t\treturn gradientAST;\n\t}\n\treturn getGradientWithPositionAtIndexChanged(\n\t\tgradientAST,\n\t\tindex,\n\t\tnewPosition\n\t);\n}\n\nexport function getGradientWithPositionAtIndexIncreased( gradientAST, index ) {\n\treturn getGradientWithPositionAtIndexSummed(\n\t\tgradientAST,\n\t\tindex,\n\t\tMINIMUM_DISTANCE_BETWEEN_POINTS\n\t);\n}\n\nexport function getGradientWithPositionAtIndexDecreased( gradientAST, index ) {\n\treturn getGradientWithPositionAtIndexSummed(\n\t\tgradientAST,\n\t\tindex,\n\t\t-MINIMUM_DISTANCE_BETWEEN_POINTS\n\t);\n}\n\nexport function getGradientWithColorAtIndexChanged(\n\tgradientAST,\n\tindex,\n\trgbaColor\n) {\n\treturn {\n\t\t...gradientAST,\n\t\tcolorStops: gradientAST.colorStops.map(\n\t\t\t( colorStop, colorStopIndex ) => {\n\t\t\t\tif ( colorStopIndex !== index ) {\n\t\t\t\t\treturn colorStop;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\t...colorStop,\n\t\t\t\t\t...tinyColorRgbToGradientColorStop( rgbaColor ),\n\t\t\t\t};\n\t\t\t}\n\t\t),\n\t};\n}\n\nexport function getGradientWithColorAtPositionChanged(\n\tgradientAST,\n\trelativePositionValue,\n\trgbaColor\n) {\n\tconst index = findIndex( gradientAST.colorStops, ( colorStop ) => {\n\t\treturn (\n\t\t\tcolorStop &&\n\t\t\tcolorStop.length &&\n\t\t\tcolorStop.length.type === '%' &&\n\t\t\tcolorStop.length.value === relativePositionValue.toString()\n\t\t);\n\t} );\n\treturn getGradientWithColorAtIndexChanged( gradientAST, index, rgbaColor );\n}\n\nexport function getGradientWithControlPointRemoved( gradientAST, index ) {\n\treturn {\n\t\t...gradientAST,\n\t\tcolorStops: gradientAST.colorStops.filter( ( elem, elemIndex ) => {\n\t\t\treturn elemIndex !== index;\n\t\t} ),\n\t};\n}\n\nexport function getHorizontalRelativeGradientPosition(\n\tmouseXCoordinate,\n\tcontainerElement,\n\tpositionedElementWidth\n) {\n\tif ( ! containerElement ) {\n\t\treturn;\n\t}\n\tconst { x, width } = containerElement.getBoundingClientRect();\n\tconst absolutePositionValue =\n\t\tmouseXCoordinate -\n\t\tx -\n\t\tMINIMUM_ABSOLUTE_LEFT_POSITION -\n\t\tpositionedElementWidth / 2;\n\tconst availableWidth =\n\t\twidth - MINIMUM_ABSOLUTE_LEFT_POSITION - INSERT_POINT_WIDTH;\n\treturn Math.round(\n\t\tMath.min(\n\t\t\tMath.max( ( absolutePositionValue * 100 ) / availableWidth, 0 ),\n\t\t\t100\n\t\t)\n\t);\n}\n\n/**\n * Returns the marker points from a gradient AST.\n *\n * @param {Object} gradientAST An object representing the gradient AST.\n *\n * @return {Array.<{color: string, position: string, positionValue: number}>}\n *         An array of markerPoint objects.\n *         color:         A string with the color code ready to be used in css style e.g: \"rgba( 1, 2 , 3, 0.5)\".\n *         position:      A string with the position ready to be used in css style e.g: \"70%\".\n *         positionValue: A number with the relative position value e.g: 70.\n */\nexport function getMarkerPoints( gradientAST ) {\n\tif ( ! gradientAST ) {\n\t\treturn [];\n\t}\n\treturn map( gradientAST.colorStops, ( colorStop ) => {\n\t\tif (\n\t\t\t! colorStop ||\n\t\t\t! colorStop.length ||\n\t\t\tcolorStop.length.type !== '%'\n\t\t) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\tcolor: serializeGradientColor( colorStop ),\n\t\t\tposition: serializeGradientPosition( colorStop.length ),\n\t\t\tpositionValue: parseInt( colorStop.length.value ),\n\t\t};\n\t} );\n}\n\nexport function getLinearGradientRepresentationOfARadial( gradientAST ) {\n\treturn serializeGradient( {\n\t\ttype: 'linear-gradient',\n\t\torientation: HORIZONTAL_GRADIENT_ORIENTATION,\n\t\tcolorStops: gradientAST.colorStops,\n\t} );\n}\n\nconst DIRECTIONAL_ORIENTATION_ANGLE_MAP = {\n\ttop: 0,\n\t'top right': 45,\n\t'right top': 45,\n\tright: 90,\n\t'right bottom': 135,\n\t'bottom right': 135,\n\tbottom: 180,\n\t'bottom left': 225,\n\t'left bottom': 225,\n\tleft: 270,\n\t'top left': 315,\n\t'left top': 315,\n};\n\nexport function getGradientParsed( value ) {\n\tlet hasGradient = !! value;\n\t// gradientAST will contain the gradient AST as parsed by gradient-parser npm module.\n\t// More information of its structure available at https://www.npmjs.com/package/gradient-parser#ast.\n\tlet gradientAST;\n\tlet gradientValue;\n\ttry {\n\t\tgradientAST = gradientParser.parse( value || DEFAULT_GRADIENT )[ 0 ];\n\t\tgradientValue = value || DEFAULT_GRADIENT;\n\t} catch ( error ) {\n\t\thasGradient = false;\n\t\tgradientAST = gradientParser.parse( DEFAULT_GRADIENT )[ 0 ];\n\t\tgradientValue = DEFAULT_GRADIENT;\n\t}\n\n\tif (\n\t\tgradientAST.orientation &&\n\t\tgradientAST.orientation.type === 'directional'\n\t) {\n\t\tgradientAST.orientation.type = 'angular';\n\t\tgradientAST.orientation.value = DIRECTIONAL_ORIENTATION_ANGLE_MAP[\n\t\t\tgradientAST.orientation.value\n\t\t].toString();\n\t}\n\treturn {\n\t\thasGradient,\n\t\tgradientAST,\n\t\tgradientValue,\n\t};\n}\n"]}