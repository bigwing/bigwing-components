{"version":3,"sources":["@wordpress/components/src/higher-order/with-focus-return/context.js"],"names":["uniq","Component","createContext","focusHistory","Provider","Consumer","displayName","MAX_STACK_LENGTH","FocusReturnProvider","arguments","onFocus","bind","state","event","nextFocusHistory","target","slice","reverse","setState","props","children","className"],"mappings":";;;;;;;;;;;;;AAAA;;;AAGA,SAASA,IAAT,QAAqB,QAArB;AAEA;;;;AAGA,SAASC,SAAT,EAAoBC,aAApB,QAAyC,oBAAzC;;qBAE+BA,aAAa,CAAE;AAC7CC,EAAAA,YAAY,EAAE;AAD+B,CAAF,C;IAApCC,Q,kBAAAA,Q;IAAUC,Q,kBAAAA,Q;;AAIlBD,QAAQ,CAACE,WAAT,GAAuB,qBAAvB;AACAD,QAAQ,CAACC,WAAT,GAAuB,qBAAvB;AAEA;;;;;;;AAMA,IAAMC,gBAAgB,GAAG,GAAzB;;IAEMC,mB;;;;;AACL,iCAAc;AAAA;;AAAA;;AACb,+BAAUC,SAAV;AAEA,UAAKC,OAAL,GAAe,MAAKA,OAAL,CAAaC,IAAb,+BAAf;AAEA,UAAKC,KAAL,GAAa;AACZT,MAAAA,YAAY,EAAE;AADF,KAAb;AALa;AAQb;;;;4BAEQU,K,EAAQ;AAAA,UACRV,YADQ,GACS,KAAKS,KADd,CACRT,YADQ,EAGhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAMW,gBAAgB,GAAGd,IAAI,CAC5B,6BAAKG,YAAL,IAAmBU,KAAK,CAACE,MAAzB,GACEC,KADF,CACS,CAAC,CAAD,GAAKT,gBADd,EAEEU,OAFF,EAD4B,CAAJ,CAIvBA,OAJuB,EAAzB;AAMA,WAAKC,QAAL,CAAe;AAAEf,QAAAA,YAAY,EAAEW;AAAhB,OAAf;AACA;;;6BAEQ;AAAA,wBACwB,KAAKK,KAD7B;AAAA,UACAC,QADA,eACAA,QADA;AAAA,UACUC,SADV,eACUA,SADV;AAGR,aACC,cAAC,QAAD;AAAU,QAAA,KAAK,EAAG,KAAKT;AAAvB,SACC;AAAK,QAAA,OAAO,EAAG,KAAKF,OAApB;AAA8B,QAAA,SAAS,EAAGW;AAA1C,SACGD,QADH,CADD,CADD;AAOA;;;;EAzCgCnB,S;;AA4ClC,eAAeO,mBAAf;AACA,SAASH,QAAT","sourcesContent":["/**\n * External dependencies\n */\nimport { uniq } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { Component, createContext } from '@wordpress/element';\n\nconst { Provider, Consumer } = createContext( {\n\tfocusHistory: [],\n} );\n\nProvider.displayName = 'FocusReturnProvider';\nConsumer.displayName = 'FocusReturnConsumer';\n\n/**\n * The maximum history length to capture for the focus stack. When exceeded,\n * items should be shifted from the stack for each consecutive push.\n *\n * @type {number}\n */\nconst MAX_STACK_LENGTH = 100;\n\nclass FocusReturnProvider extends Component {\n\tconstructor() {\n\t\tsuper( ...arguments );\n\n\t\tthis.onFocus = this.onFocus.bind( this );\n\n\t\tthis.state = {\n\t\t\tfocusHistory: [],\n\t\t};\n\t}\n\n\tonFocus( event ) {\n\t\tconst { focusHistory } = this.state;\n\n\t\t// Push the focused element to the history stack, keeping only unique\n\t\t// members but preferring the _last_ occurrence of any duplicates.\n\t\t// Lodash's `uniq` behavior favors the first occurrence, so the array\n\t\t// is temporarily reversed prior to it being called upon. Uniqueness\n\t\t// helps avoid situations where, such as in a constrained tabbing area,\n\t\t// the user changes focus enough within a transient element that the\n\t\t// stack may otherwise only consist of members pending destruction, at\n\t\t// which point focus might have been lost.\n\t\tconst nextFocusHistory = uniq(\n\t\t\t[ ...focusHistory, event.target ]\n\t\t\t\t.slice( -1 * MAX_STACK_LENGTH )\n\t\t\t\t.reverse()\n\t\t).reverse();\n\n\t\tthis.setState( { focusHistory: nextFocusHistory } );\n\t}\n\n\trender() {\n\t\tconst { children, className } = this.props;\n\n\t\treturn (\n\t\t\t<Provider value={ this.state }>\n\t\t\t\t<div onFocus={ this.onFocus } className={ className }>\n\t\t\t\t\t{ children }\n\t\t\t\t</div>\n\t\t\t</Provider>\n\t\t);\n\t}\n}\n\nexport default FocusReturnProvider;\nexport { Consumer };\n"]}