{"version":3,"file":"react-use-gesture.cjs.production.min.js","sources":["../src/utils/math.ts","../src/utils/utils.ts","../src/utils/state.ts","../src/utils/event.ts","../src/Controller.ts","../src/hooks/useRecognizers.ts","../src/recognizers/Recognizer.ts","../src/recognizers/CoordinatesRecognizer.ts","../src/recognizers/DragRecognizer.ts","../src/utils/config.ts","../src/recognizers/PinchRecognizer.ts","../src/recognizers/DistanceAngleRecognizer.ts","../src/recognizers/WheelRecognizer.ts","../src/recognizers/MoveRecognizer.ts","../src/recognizers/ScrollRecognizer.ts","../src/hooks/useGesture.ts","../src/hooks/useDrag.ts","../src/hooks/useHover.ts","../src/hooks/useMove.ts","../src/hooks/usePinch.ts","../src/hooks/useScroll.ts","../src/hooks/useWheel.ts"],"sourcesContent":["// vector add\nexport function addV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v + v2[i]) as T\n}\n\n// vector substract\nexport function subV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v - v2[i]) as T\n}\n/**\n * Calculates velocity\n * @param delta the difference between current and previous vectors\n * @param delta_t the time offset\n * @param len the length of the delta vector\n * @returns velocity\n */\nexport function calculateVelocity(delta: number[], delta_t: number, len: number): number {\n  len = len || Math.hypot(...delta)\n  return delta_t ? len / delta_t : 0\n}\n\n/**\n * Calculates velocities vector\n * @template T the expected vector type\n * @param delta the difference between current and previous vectors\n * @param delta_t the time offset\n * @returns velocities vector\n */\nexport function calculateVelocities<T extends number[]>(delta: T, delta_t: number): T {\n  return (delta_t ? delta.map(v => v / delta_t) : Array(delta.length).fill(0)) as T\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\n/**\n * Calculates direction\n * @template T the expected vector type\n * @param delta\n * @param len\n * @returns direction\n */\nexport function calculateDirection<T extends number[]>(delta: T, len?: number): T {\n  len = len || Math.hypot(...delta) || 1\n  return delta.map(v => v / len!) as T\n}\n\ninterface Kinematics<T extends number[]> {\n  velocities: T\n  velocity: number\n  distance: number\n  direction: T\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, delta_t: number): Kinematics<T> {\n  const len = Math.hypot(...delta)\n\n  return {\n    velocities: calculateVelocities(delta, delta_t),\n    velocity: calculateVelocity(delta, delta_t, len),\n    distance: calculateDistance(movement),\n    direction: calculateDirection(delta, len),\n  }\n}\n\nexport function getIntentionalDisplacement(movement: number, threshold: number): number | false {\n  const abs = Math.abs(movement)\n  return abs >= threshold ? Math.sign(movement) * threshold : false\n}\n\nfunction minMax(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n\n// Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance: number, constant: number) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5)\n}\n\nfunction rubberband(distance: number, dimension: number, constant: number) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant)\n  return (distance * dimension * constant) / (dimension + constant * distance)\n}\n\nexport function rubberbandIfOutOfBounds(position: number, min: number, max: number, constant = 0.15) {\n  if (constant === 0) return minMax(position, min, max)\n\n  if (position < min) {\n    return -rubberband(min - position, max - min, constant) + min\n  }\n  if (position > max) {\n    return rubberband(position - max, max - min, constant) + max\n  }\n  return position\n}\n","import { Fn, Vector2 } from '../types'\n\n// blank function\nexport function noop() {}\n// returns a function that chains all functions given as parameters\nexport const chainFns = (...fns: Fn[]): Fn => (...args: any[]) => fns.forEach(fn => fn(...args))\n\nexport const def = {\n  array: <T>(value: T | T[]): T[] => (Array.isArray(value) ? value : [value, value]),\n  withDefault: <T>(value: T | undefined, defaultIfUndefined: T): T => (value !== void 0 ? value : defaultIfUndefined),\n}\n\nexport function matchKeysFromObject<T extends object, K extends object>(obj: T, matchingObject: K): Partial<T> {\n  const o: Partial<T> = {}\n  Object.entries(obj).forEach(\n    ([key, value]) => (value !== void 0 || key in matchingObject) && (o[key as keyof T] = value)\n  )\n  return o\n}\n\nexport function valueFn(v: Vector2 | (() => Vector2)) {\n  return typeof v === 'function' ? v() : v\n}\n","import { noop } from './utils'\nimport { CommonGestureState, Coordinates, State, DistanceAngle, Vector2 } from '../types'\n\nexport function getInitialState(): State {\n  // common initial state for all gestures\n  const initialCommon: CommonGestureState = {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _lastEventType: undefined,\n    event: undefined,\n    // currentTarget: undefined,\n    // pointerId: undefined,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined,\n  }\n\n  // initial state for coordinates-based gestures\n  const initialCoordinates: Coordinates = {\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  }\n\n  // initial state for distance and angle-based gestures (pinch)\n  const initialDistanceAngle: DistanceAngle = {\n    da: [0, 0] as Vector2,\n    vdva: [0, 0] as Vector2,\n    origin: undefined,\n    turns: 0,\n  }\n\n  // initial state object (used by the gesture controller)\n  return {\n    shared: {\n      hovering: false,\n      scrolling: false,\n      wheeling: false,\n      dragging: false,\n      moving: false,\n      pinching: false,\n      touches: 0,\n      buttons: 0,\n      down: false,\n      shiftKey: false,\n      altKey: false,\n      metaKey: false,\n      ctrlKey: false,\n    },\n    drag: {\n      ...initialCommon,\n      ...initialCoordinates,\n      _isTap: true,\n      _delayedEvent: false,\n      tap: false,\n      swipe: [0, 0],\n    },\n    pinch: { ...initialCommon, ...initialDistanceAngle },\n    wheel: { ...initialCommon, ...initialCoordinates },\n    move: { ...initialCommon, ...initialCoordinates },\n    scroll: { ...initialCommon, ...initialCoordinates },\n  }\n}\n","import { Fn, EventOptions, UseGestureEvent, Vector2, WebKitGestureEvent } from '../types'\n\nconst isBrowser = typeof window !== 'undefined'\n\nexport const supportsTouchEvents = () => isBrowser && window.ontouchstart === null\n\nconst setListeners = (add: boolean) => (el: EventTarget, listeners: [string, Fn][], options: EventOptions): void => {\n  const action = add ? 'addEventListener' : 'removeEventListener'\n  listeners.forEach(([eventName, fn]) => el[action](eventName, fn, options))\n}\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvents(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n\nexport const addListeners = setListeners(true)\nexport const removeListeners = setListeners(false)\n\ninterface ModifierKeys {\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  ctrlKey: boolean\n}\n\n/**\n * Gets modifier keys from event\n * @param event\n * @returns modifier keys\n */\nexport function getModifierKeys(event: UseGestureEvent): ModifierKeys {\n  const { shiftKey, altKey, metaKey, ctrlKey } = event\n  return { shiftKey, altKey, metaKey, ctrlKey }\n}\n\nfunction getTouchEvents(event: UseGestureEvent) {\n  if ('touches' in event) {\n    const { touches, changedTouches } = event\n    return touches.length > 0 ? touches : changedTouches\n  }\n  return null\n}\n\nexport function getGenericEventData(event: React.MouseEvent | React.TouchEvent | React.PointerEvent) {\n  const buttons = 'buttons' in event ? event.buttons : 0\n  const touchEvents = getTouchEvents(event)\n  const touches = (touchEvents && touchEvents.length) || 0\n  const down = touches > 0 || buttons > 0\n  return { touches, down, buttons, ...getModifierKeys(event) }\n}\n\ntype Values = { values: Vector2 }\n\n/**\n * Gets scroll event values\n * @param event\n * @returns scroll event values\n */\nexport function getScrollEventValues(event: UseGestureEvent): Values {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\n  return { values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0] }\n}\n\n/**\n * Gets wheel event values.\n * @param event\n * @returns wheel event values\n */\nexport function getWheelEventValues(event: UseGestureEvent<React.WheelEvent>): Values {\n  const { deltaX, deltaY } = event\n  //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n  return { values: [deltaX, deltaY] }\n}\n\n/**\n * Gets pointer event values.\n * @param event\n * @returns pointer event values\n */\nexport function getPointerEventValues(event: React.MouseEvent | React.TouchEvent | React.PointerEvent): Values {\n  const touchEvents = getTouchEvents(event)\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : (event as React.PointerEvent)\n  return { values: [clientX, clientY] }\n}\n\nconst WEBKIT_DISTANCE_SCALE_FACTOR = 260\n\n/**\n * Gets webkit gesture event values.\n * @param event\n * @returns webkit gesture event values\n */\nexport function getWebkitGestureEventValues(event: WebKitGestureEvent): Values {\n  return { values: [event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation] as Vector2 }\n}\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventData(event: React.TouchEvent) {\n  const { touches } = event\n  const dx = touches[1].clientX - touches[0].clientX\n  const dy = touches[1].clientY - touches[0].clientY\n\n  const values: Vector2 = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI]\n  const origin: Vector2 = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2]\n\n  return { values, origin }\n}\n","import {\n  StateKey,\n  State,\n  Fn,\n  ReactEventHandlerKey,\n  ReactEventHandlers,\n  InternalConfig,\n  InternalHandlers,\n} from './types'\nimport { getInitialState } from './utils/state'\nimport { addListeners, removeListeners } from './utils/event'\nimport { chainFns } from './utils/utils'\n\ntype GestureTimeouts = Partial<{ [stateKey in StateKey]: number }>\ntype WindowListeners = Partial<{ [stateKey in StateKey]: [string, Fn][] }>\ntype Bindings = Partial<{ [eventName in ReactEventHandlerKey]: Fn[] }>\n\n/**\n * The controller will keep track of the state for all gestures and also keep\n * track of timeouts, and window listeners.\n *\n * @template BinderType the type the bind function should return\n */\nexport default class Controller {\n  public config!: InternalConfig\n  public handlers!: Partial<InternalHandlers>\n  public state: State = getInitialState() // state for all gestures\n  public timeouts: GestureTimeouts = {} // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n  private domListeners: [string, Fn][] = [] // when config.domTarget is set, we attach events directly to the dom\n  private windowListeners: WindowListeners = {} // keeps track of window listeners added by gestures (drag only at the moment)\n  private bindings: Bindings = {} // an object holding the handlers associated to the gestures\n\n  /**\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\n   */\n  public clean = (): void => {\n    this.resetBindings()\n    Object.values(this.timeouts).forEach(clearTimeout)\n    Object.keys(this.windowListeners).forEach(stateKey => this.removeWindowListeners(stateKey as StateKey))\n  }\n\n  /**\n   * Function run every time the bind function is run (ie on every render).\n   * Resets the binding object and remove dom listeners attached to config.domTarget\n   */\n  public resetBindings = (): void => {\n    this.bindings = {}\n    const domTarget = this.getDomTarget()\n    if (domTarget) {\n      removeListeners(domTarget, this.domListeners, this.config.eventOptions)\n      this.domListeners = []\n    }\n  }\n\n  /**\n   * Returns the domTarget element and parses a ref if needed.\n   */\n  private getDomTarget = (): EventTarget | null | undefined => {\n    const { domTarget } = this.config\n    return domTarget && 'current' in domTarget ? domTarget.current : domTarget\n  }\n\n  /**\n   * Commodity function to let recognizers simply add listeners to config.window.\n   */\n  public addWindowListeners = (stateKey: StateKey, listeners: [string, Fn][]): void => {\n    if (!this.config.window) return\n    // we use this.windowListeners to keep track of the listeners we add\n    this.windowListeners[stateKey] = listeners\n    addListeners(this.config.window, listeners, this.config.eventOptions)\n  }\n\n  /**\n   * Commodity function to let recognizers simply remove listeners to config.window.\n   */\n  public removeWindowListeners = (stateKey: StateKey): void => {\n    if (!this.config.window) return\n    const listeners = this.windowListeners[stateKey]\n    if (listeners) {\n      removeListeners(this.config.window, listeners, this.config.eventOptions)\n      delete this.windowListeners[stateKey]\n    }\n  }\n\n  /**\n   * When config.domTarget is set, this function will add dom listeners to it\n   */\n  public addDomTargetListeners = (target: EventTarget): void => {\n    /** We iterate on the entries of this.binding for each event, then we chain\n     * the array of functions mapped to it and push them to this.domListeners\n     */\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      this.domListeners.push([event.substr(2).toLowerCase(), chainFns(...(fns as Fn[]))])\n    })\n\n    addListeners(target, this.domListeners, this.config.eventOptions)\n  }\n\n  /**\n   * this.bindings is an object which keys match ReactEventHandlerKeys.\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n   * that key.\n   */\n  public addBindings = (eventNames: ReactEventHandlerKey | ReactEventHandlerKey[], fn: Fn): void => {\n    const eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames\n    eventNamesArray.forEach(eventName => {\n      if (this.bindings[eventName]) this.bindings[eventName]!.push(fn)\n      else this.bindings[eventName] = [fn]\n    })\n  }\n\n  /**\n   * getBindings will return an object that will be bound by users\n   * to the react component they want to interact with.\n   */\n  public getBindings = (): ReactEventHandlers => {\n    const bindings: ReactEventHandlers = {}\n    const { captureString } = this.config\n\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      const fnsArray = Array.isArray(fns) ? fns : [fns]\n      const key = (event + captureString) as ReactEventHandlerKey\n      bindings[key] = chainFns(...(fnsArray as Fn[]))\n    })\n\n    return bindings\n  }\n\n  public getBind = () => {\n    // If config.domTarget is set we add event listeners to it and return the clean function.\n    if (this.config.domTarget) {\n      const domTarget = this.getDomTarget()\n      domTarget && this.addDomTargetListeners(domTarget)\n      return this.clean\n    }\n\n    // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n    return this.getBindings()\n  }\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport React from 'react'\nimport Controller from '../Controller'\nimport {\n  InternalConfig,\n  HookReturnType,\n  InternalHandlers,\n  RecognizerClasses,\n  GenericOptions,\n  NativeHandlersPartial,\n  ReactEventHandlerKey,\n  Fn,\n} from '../types'\n/**\n * @private\n *\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\n *\n * @param {Partial<InternalHandlers>} handlers\n * @param {RecognizerClasses} classes\n * @param {InternalConfig} config\n * @param {NativeHandlersPartial} nativeHandlers - native handlers such as onClick, onMouseDown, etc.\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport default function useRecognizers<Config extends Partial<GenericOptions>>(\n  handlers: Partial<InternalHandlers>,\n  classes: RecognizerClasses,\n  config: InternalConfig,\n  nativeHandlers?: NativeHandlersPartial\n): (...args: any[]) => HookReturnType<Config> {\n  // The gesture controller keeping track of all gesture states\n  const controller = React.useMemo(() => {\n    const current = new Controller()\n\n    /**\n     * The bind function will create gesture recognizers and return the right\n     * bind object depending on whether `domTarget` was specified in the config object.\n     */\n    const bind = (...args: any[]) => {\n      current.resetBindings()\n      for (let RecognizerClass of classes) {\n        new RecognizerClass(current, args).addBindings()\n      }\n\n      // we also add event bindings for native handlers\n      if (controller.nativeRefs) {\n        for (let eventName in controller.nativeRefs)\n          current.addBindings(\n            eventName as ReactEventHandlerKey,\n            // @ts-ignore we're cheating when it comes to event type :(\n            controller.nativeRefs[eventName] as Fn\n          )\n      }\n\n      return current.getBind() as HookReturnType<Config>\n    }\n\n    return { nativeRefs: nativeHandlers, current, bind }\n  }, [])\n\n  // We reassign the config and handlers to the controller on every render.\n  controller.current!.config = config\n  controller.current!.handlers = handlers\n  // We assign nativeHandlers, otherwise they won't be refreshed on the next render.\n  controller.nativeRefs = nativeHandlers\n\n  // Run controller clean functions on unmount.\n  React.useEffect(() => controller.current!.clean, [])\n\n  return controller.bind\n}\n","import Controller from '../Controller'\nimport {\n  StateKey,\n  SharedGestureState,\n  Fn,\n  UseGestureEvent,\n  IngKey,\n  InternalConfig,\n  GestureState,\n  PartialGestureState,\n  Vector2,\n  FalseOrNumber,\n  FullGestureState,\n} from '../types'\nimport { getInitialState } from '../utils/state'\nimport { subV, addV, getIntentionalDisplacement, rubberbandIfOutOfBounds } from '../utils/math'\nimport { valueFn } from '../utils/utils'\n\n/**\n * @private\n * Recognizer abstract class.\n *\n * @protected\n * @abstract\n * @type {StateKey<T>} whether the Recognizer should deal with coordinates or distance / angle\n */\nexport default abstract class Recognizer<T extends StateKey> {\n  protected abstract ingKey: IngKey // dragging, scrolling, etc.\n  protected debounced: Boolean = true\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param stateKey drag, move, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(\n    protected readonly stateKey: T,\n    protected readonly controller: Controller,\n    protected readonly args: any[] = []\n  ) {}\n\n  // Returns the gesture config\n  protected get config(): NonNullable<InternalConfig[T]> {\n    return this.controller.config[this.stateKey]!\n  }\n\n  // Is the gesture enabled\n  protected get enabled(): boolean {\n    return this.controller.config.enabled && this.config.enabled\n  }\n\n  // Returns the controller state for a given gesture\n  protected get state(): GestureState<T> {\n    return this.controller.state[this.stateKey]\n  }\n\n  // Returns the gesture handler\n  protected get handler() {\n    return this.controller.handlers[this.stateKey]!\n  }\n\n  // Conveninence method to update the shared state\n  protected updateSharedState(sharedState: Partial<SharedGestureState> | null) {\n    Object.assign(this.controller.state.shared, sharedState)\n  }\n\n  // Conveninence method to update the gesture state\n  protected updateGestureState(gestureState: PartialGestureState<T> | null) {\n    Object.assign(this.state, gestureState)\n  }\n\n  // Convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // Convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  // Convenience method to add window listeners for a given gesture\n  protected addWindowListeners = (listeners: [string, Fn][]) => {\n    this.controller.addWindowListeners(this.stateKey, listeners)\n  }\n\n  // Convenience method to remove window listeners for a given gesture\n  protected removeWindowListeners = () => {\n    this.controller.removeWindowListeners(this.stateKey)\n  }\n\n  /**\n   * Utility function to get kinematics of the gesture.\n   *\n   * @abstract\n   * @values - values we want to calculate the kinematics from\n   * @event - the pointer event\n   * @returns - set of values including movement, velocity, velocities, distance and direction\n   */\n  protected abstract getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T>\n\n  protected abstract mapStateValues(state: GestureState<T>): PartialGestureState<T>\n\n  // Should return the bindings to be added for a given gesture\n  public abstract addBindings(): void\n\n  /**\n   * Returns a generic, common payload for all gestures from an event.\n   *\n   * @param {UseGestureEvent} event\n   * @param {boolean} [isStartEvent]\n   * @returns - the generic gesture payload\n   */\n  protected getGenericPayload(event: UseGestureEvent, isStartEvent?: boolean) {\n    const { timeStamp, type } = event\n    const { values, startTime } = this.state\n\n    return {\n      _lastEventType: type,\n      event,\n      timeStamp,\n      elapsedTime: isStartEvent ? 0 : timeStamp - startTime!,\n      args: this.args,\n      previous: values,\n    }\n  }\n  /**\n   * Returns the reinitialized start state for the gesture.\n   * Should be common to all gestures.\n   *\n   * @param {Vector2} values\n   * @param {UseGestureEvent} event\n   * @returns - the start state for the gesture\n   */\n  protected getStartGestureState = (values: Vector2, event: UseGestureEvent) => {\n    return {\n      ...getInitialState()[this.stateKey],\n      _active: true,\n      values,\n      initial: values,\n      offset: this.state.offset,\n      lastOffset: this.state.offset,\n      startTime: event.timeStamp,\n    }\n  }\n\n  /**\n   * Returns state properties depending on the movement and state.\n   *\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\n   * below.\n   */\n  protected checkIntentionality(\n    _intentional: [FalseOrNumber, FalseOrNumber],\n    _movement: Vector2,\n    _state: PartialGestureState<T>\n  ): PartialGestureState<T> {\n    return { _intentional, _blocked: false } as PartialGestureState<T>\n  }\n\n  protected abstract getInternalMovement(values: Vector2, state: GestureState<T>): Vector2\n\n  /**\n   * Returns basic movement properties for the gesture based on the next values and current state.\n   */\n  protected getMovement(values: Vector2, state: GestureState<T> = this.state): PartialGestureState<T> {\n    const { initial, threshold, rubberband } = this.config\n\n    const [t0, t1] = threshold\n\n    const { _initial, _active, _intentional: intentional, lastOffset, movement: prevMovement } = state\n    let [i0, i1] = intentional\n\n    const [_m0, _m1] = this.getInternalMovement(values, state)\n\n    /**\n     * For both dimensions of the gesture, check its intentionality on each frame.\n     */\n    if (i0 === false) {\n      i0 = getIntentionalDisplacement(_m0, t0)\n    }\n    if (i1 === false) {\n      i1 = getIntentionalDisplacement(_m1, t1)\n    }\n\n    // Get gesture specific state properties based on intentionality and movement.\n    const intentionalityCheck = this.checkIntentionality([i0, i1], [_m0, _m1], state)\n\n    const { _intentional, _blocked } = intentionalityCheck\n    const [_i0, _i1] = _intentional!\n    const _movement = [_m0, _m1]\n\n    if (_i0 !== false && intentional[0] === false) _initial[0] = valueFn(initial)[0]\n    if (_i1 !== false && intentional[1] === false) _initial[1] = valueFn(initial)[1]\n\n    /**\n     * If the gesture has been blocked (from gesture specific checkIntentionality),\n     * stop right there.\n     */\n    if (_blocked) return { ...intentionalityCheck, _movement, delta: [0, 0] }\n\n    /**\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\n     * It is calculated from the actual movement minus the threshold.\n     */\n    let movement = [\n      _i0 !== false ? _m0 - _i0 : valueFn(initial)[0],\n      _i1 !== false ? _m1 - _i1 : valueFn(initial)[1],\n    ] as Vector2\n    const offset = addV(movement, lastOffset)\n\n    /**\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\n     * and offset can return within their bounds.\n     */\n    const _rubberband: Vector2 = _active ? rubberband : [0, 0]\n    movement = this.rubberband(addV(movement, _initial), _rubberband) // rubberbanded movement\n\n    return {\n      ...intentionalityCheck,\n      _initial,\n      _movement,\n      movement,\n      offset: this.rubberband(offset, _rubberband), // rubberbanded offset\n      delta: subV(movement, prevMovement),\n    } as PartialGestureState<T>\n  }\n\n  // Runs rubberband on a vector\n  protected rubberband = (vector: Vector2, rubberband: Vector2): Vector2 => {\n    const { bounds } = this.config\n\n    /**\n     * [x, y]: [rubberband(x, min, max), rubberband(y, min, max)]\n     */\n    return vector.map((v, i) => rubberbandIfOutOfBounds(v, bounds[i][0], bounds[i][1], rubberband[i])) as Vector2\n  }\n\n  // Cleans the gesture. Can be overriden by gestures.\n  protected clean() {\n    this.clearTimeout()\n    this.removeWindowListeners()\n  }\n\n  /**\n   * Fires the gesture handler\n   *\n   * @param {boolean} [forceFlag] - if true, then the handler will fire even if the gesture is not intentional\n   */\n  protected fireGestureHandler = (forceFlag?: boolean): FullGestureState<T> | null => {\n    /**\n     * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\n     * clean everything and don't do anything.\n     */\n    if (this.state._blocked) {\n      // we need debounced gestures to end by themselves\n      if (!this.debounced) {\n        this.state._active = false\n        this.clean()\n      }\n      return null\n    }\n\n    // If the gesture has no intentional dimension, don't do fire the handler.\n    const [intentionalX, intentionalY] = this.state._intentional\n    if (!forceFlag && intentionalX === false && intentionalY === false) return null\n\n    const { _active, active } = this.state\n\n    this.state.active = _active\n    this.state.first = _active && !active // `first` is true when the gesture becomes active\n    this.state.last = active && !_active // `last` is true when the gesture becomes inactive\n\n    this.controller.state.shared[this.ingKey] = _active // Sets dragging, pinching, etc. to the gesture active state\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...this.mapStateValues(this.state), // Sets xy or da to the gesture state values\n    } as FullGestureState<T>\n\n    // @ts-ignore\n    const newMemo = this.handler(state)\n\n    // Sets memo to the returned value of the handler (unless it's not undefined)\n    this.state.memo = newMemo !== void 0 ? newMemo : this.state.memo\n\n    // Cleans the gesture when the gesture is no longer active.\n    if (!_active) this.clean()\n\n    return state\n  }\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, subV } from '../utils/math'\nimport { Vector2, UseGestureEvent, PartialGestureState, FalseOrNumber, GestureState, CoordinatesKey } from '../types'\n\n/**\n * @private\n * Abstract class for coordinates-based gesture recongizers\n * @abstract\n * @class CoordinatesRecognizer\n * @extends {Recognizer<T>}\n * @template T\n */\nexport default abstract class CoordinatesRecognizer<T extends CoordinatesKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into acount)\n   */\n  protected getInternalMovement(values: Vector2, state: GestureState<T>): Vector2 {\n    return subV(values, state.initial)\n  }\n\n  /**\n   * In coordinates-based gesture, this function will detect the first intentional axis,\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\n   * if the first intentional axis doesn't match the specified axis in config.\n   *\n   * @param {[FalseOrNumber, FalseOrNumber]} _intentional\n   * @param {Vector2} _movement\n   * @param {PartialGestureState<T>} state\n   */\n  protected checkIntentionality(\n    _intentional: [FalseOrNumber, FalseOrNumber],\n    _movement: Vector2,\n    state: PartialGestureState<T>\n  ): PartialGestureState<T> {\n    let [_ix, _iy] = _intentional\n    const intentionalMovement = _ix !== false || _iy !== false\n    let { axis } = state\n    let _blocked = false\n\n    // If the movement is intentional, we can compute axis.\n    if (intentionalMovement) {\n      const [absX, absY] = _movement.map(Math.abs)\n\n      const { axis: configAxis, lockDirection } = this.config\n\n      // We make sure we only set axis value if it hadn't been detected before.\n      axis = axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined)\n      if (!!configAxis || lockDirection) {\n        if (!!axis) {\n          // If the detected axis doesn't match the config axis we block the gesture\n          if (!!configAxis && axis !== configAxis) _blocked = true\n          else {\n            // Otherwise we prevent the gesture from updating the unwanted axis.\n            const lockedIndex = axis === 'x' ? 1 : 0\n            _intentional![lockedIndex] = false\n          }\n        } else {\n          // Until we've detected the axis, we prevent the hnadler from updating.\n          _intentional = [false, false]\n        }\n      }\n    }\n\n    return { _intentional, _blocked, axis } as PartialGestureState<T>\n  }\n\n  getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T> {\n    const { timeStamp } = this.state\n\n    const movementDetection = this.getMovement(values, this.state)\n    const { _blocked, delta, movement } = movementDetection\n\n    if (_blocked) return movementDetection\n\n    const delta_t = event.timeStamp - timeStamp!\n    const kinematics = calculateAllKinematics(movement!, delta!, delta_t)\n\n    return {\n      values,\n      delta,\n      ...movementDetection,\n      ...kinematics,\n    }\n  }\n\n  protected mapStateValues(state: GestureState<T>): PartialGestureState<T> {\n    return { xy: state.values, vxvy: state.velocities } as PartialGestureState<T>\n  }\n}\n","import { PointerEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, Fn, IngKey } from '../types'\nimport { noop } from '../utils/utils'\nimport { getPointerEventValues, getGenericEventData } from '../utils/event'\nimport { calculateDistance } from '../utils/math'\n\nconst TAP_DISTANCE_THRESHOLD = 3\nconst SWIPE_MAX_ELAPSED_TIME = 220\nconst FILTER_REPEATED_EVENTS_DELAY = 200\n\nexport default class DragRecognizer extends CoordinatesRecognizer<'drag'> {\n  ingKey = 'dragging' as IngKey\n  wasTouch = false\n\n  constructor(controller: Controller, args: any[]) {\n    super('drag', controller, args)\n  }\n\n  private isEventTypeTouch = (type?: string) => !!type && type.indexOf('touch') === 0\n\n  private dragShouldStart = (event: UseGestureEvent) => {\n    const { touches } = getGenericEventData(event)\n    const { _lastEventType } = this.state\n    /**\n     * This tries to filter out mouse events triggered by touch screens\n     * */\n    // If the previous gesture was touch-based, and the current one is mouse based,\n    // this means that we might be dealing with mouse simulated events if they're close to\n    // each other. We're only doing this check when we're not using pointer events.\n    if (\n      !this.controller.config.pointer &&\n      this.isEventTypeTouch(_lastEventType) &&\n      !this.isEventTypeTouch(event.type)\n    ) {\n      const delay = Math.abs(event.timeStamp - this.state.startTime)\n      if (delay < FILTER_REPEATED_EVENTS_DELAY) return false\n    }\n\n    return this.enabled && touches < 2\n  }\n\n  private setPointers = (event: UseGestureEvent<PointerEvent>) => {\n    const { currentTarget, pointerId } = event\n    if (currentTarget) currentTarget.setPointerCapture(pointerId)\n    this.updateGestureState({ currentTarget, pointerId })\n  }\n\n  private removePointers = () => {\n    const { currentTarget, pointerId } = this.state\n    if (currentTarget && pointerId) currentTarget.releasePointerCapture(pointerId)\n  }\n\n  private setListeners = (isTouch: boolean) => {\n    this.removeWindowListeners()\n    const dragListeners: [string, Fn][] = isTouch\n      ? [\n          ['touchmove', this.onDragChange],\n          ['touchend', this.onDragEnd],\n          ['touchcancel', this.onDragEnd],\n        ]\n      : [\n          ['mousemove', this.onDragChange],\n          ['mouseup', this.onDragEnd],\n        ]\n    this.addWindowListeners(dragListeners)\n  }\n\n  onDragStart = (event: UseGestureEvent): void => {\n    if (!this.dragShouldStart(event)) return\n    // if pointers events\n    if (this.controller.config.pointer) this.setPointers(event as PointerEvent)\n    else this.setListeners(this.isEventTypeTouch(event.type))\n\n    if (this.config.delay > 0) {\n      this.state._delayedEvent = true\n      if (typeof event.persist === 'function') event.persist()\n      this.setTimeout(() => this.startDrag(event), this.config.delay)\n    } else {\n      this.startDrag(event)\n    }\n  }\n\n  startDrag(event: UseGestureEvent) {\n    const { values } = getPointerEventValues(event)\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onDragChange = (event: UseGestureEvent): void => {\n    const { canceled } = this.state\n    if (canceled) return\n\n    if (!this.state._active) {\n      if (this.state._delayedEvent) {\n        this.clearTimeout()\n        this.startDrag(event)\n      }\n      return\n    }\n\n    const genericEventData = getGenericEventData(event)\n\n    if (!genericEventData.down) {\n      this.onDragEnd(event)\n      return\n    }\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getPointerEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    let { _isTap } = this.state\n    if (_isTap && calculateDistance(kinematics._movement!) >= TAP_DISTANCE_THRESHOLD) _isTap = false\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      _isTap,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onDragEnd = (event: UseGestureEvent): void => {\n    this.state._active = false\n    this.updateSharedState({ down: false, buttons: 0, touches: 0 })\n\n    const {\n      _isTap,\n      values,\n      velocities: [vx, vy],\n      movement: [mx, my],\n      _intentional: [ix, iy],\n    } = this.state\n\n    const endState = {\n      ...this.getGenericPayload(event),\n      ...this.getMovement(values),\n    }\n\n    const { elapsedTime } = endState\n\n    const {\n      swipeVelocity: [svx, svy],\n      swipeDistance: [sx, sy],\n    } = this.config\n\n    const swipe: [number, number] = [0, 0]\n\n    if (elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n      if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = Math.sign(vx)\n      if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = Math.sign(vy)\n    }\n\n    this.updateGestureState({\n      event,\n      ...endState,\n      tap: _isTap,\n      swipe,\n    })\n    this.fireGestureHandler(this.config.filterTaps && this.state._isTap)\n  }\n\n  clean = (): void => {\n    super.clean()\n    this.state._delayedEvent = false\n\n    if (this.controller.config.pointer) this.removePointers()\n  }\n\n  onCancel = (): void => {\n    this.updateGestureState({ canceled: true, cancel: noop })\n    this.state._active = false\n    this.updateSharedState({ down: false, buttons: 0, touches: 0 })\n    requestAnimationFrame(() => this.fireGestureHandler())\n  }\n\n  addBindings(): void {\n    if (this.controller.config.pointer) {\n      this.controller.addBindings('onPointerDown', this.onDragStart)\n      this.controller.addBindings('onPointerMove', this.onDragChange)\n      this.controller.addBindings(['onPointerUp', 'onPointerCancel'], this.onDragEnd)\n    } else {\n      this.controller.addBindings(['onTouchStart', 'onMouseDown'], this.onDragStart)\n    }\n  }\n}\n","import { def, matchKeysFromObject } from './utils'\nimport {\n  Vector2,\n  GenericOptions,\n  InternalGenericOptions,\n  DragConfig,\n  Tuple,\n  GestureOptions,\n  InternalDragOptions,\n  InternalGestureOptions,\n  CoordinatesConfig,\n  CoordinatesOptions,\n  InternalCoordinatesOptions,\n  DistanceAngleConfig,\n  InternalDistanceAngleOptions,\n} from '../types'\n\nconst DEFAULT_DRAG_DELAY = 180\nconst DEFAULT_RUBBERBAND = 0.15\nconst DEFAULT_SWIPE_VELOCITY = 0.5\nconst DEFAULT_SWIPE_DISTANCE = 60\n\nconst defaultWindow = typeof window !== 'undefined' ? window : undefined\n\nconst defaultCoordinatesOptions: CoordinatesOptions = {\n  lockDirection: false,\n  axis: undefined,\n  bounds: undefined,\n}\n\n/**\n * @private\n *\n * Returns the internal generic option object.\n *\n * @param {Partial<GenericOptions>} [config={}]\n * @returns {InternalGenericOptions}\n */\nexport function getInternalGenericOptions(config: Partial<GenericOptions> = {}): InternalGenericOptions {\n  let {\n    eventOptions: { passive = true, capture = false, pointer = false } = {},\n    window = defaultWindow,\n    domTarget = undefined,\n    enabled = true,\n    ...restConfig\n  } = config\n\n  return {\n    ...restConfig,\n    enabled,\n    domTarget,\n    window,\n    // passive is always true if there's no domTarget\n    eventOptions: { passive: !domTarget || !!passive, capture: !!capture },\n    captureString: capture ? 'Capture' : '',\n    pointer: !!pointer,\n  }\n}\n\nexport function getInternalGestureOptions(gestureConfig: Partial<GestureOptions>): InternalGestureOptions {\n  let { threshold = undefined, rubberband = 0, enabled = true, initial = [0, 0] } = gestureConfig\n\n  if (typeof rubberband === 'boolean') rubberband = rubberband ? DEFAULT_RUBBERBAND : 0\n  if (threshold === void 0) threshold = 0\n\n  return {\n    enabled,\n    initial,\n    threshold: def.array(threshold) as Vector2,\n    rubberband: def.array(rubberband) as Vector2,\n  }\n}\n\nexport function getInternalCoordinatesOptions(coordinatesConfig: CoordinatesConfig = {}): InternalCoordinatesOptions {\n  const { axis, lockDirection, bounds = {}, ...internalOptions } = coordinatesConfig\n\n  const boundsArray = [\n    [def.withDefault(bounds.left, -Infinity), def.withDefault(bounds.right, Infinity)],\n    [def.withDefault(bounds.top, -Infinity), def.withDefault(bounds.bottom, Infinity)],\n  ]\n\n  return {\n    ...getInternalGestureOptions(internalOptions),\n    ...defaultCoordinatesOptions,\n    ...matchKeysFromObject({ axis, lockDirection }, coordinatesConfig),\n    bounds: boundsArray as Tuple<Vector2>,\n  }\n}\n\nexport function getInternalDistanceAngleOptions(\n  distanceAngleConfig: DistanceAngleConfig = {}\n): InternalDistanceAngleOptions {\n  const { distanceBounds = {}, angleBounds = {}, ...internalOptions } = distanceAngleConfig\n\n  const boundsArray = [\n    [def.withDefault(distanceBounds.min, -Infinity), def.withDefault(distanceBounds.max, Infinity)],\n    [def.withDefault(angleBounds.min, -Infinity), def.withDefault(angleBounds.max, Infinity)],\n  ]\n\n  return {\n    ...getInternalGestureOptions(internalOptions),\n    bounds: boundsArray as Tuple<Vector2>,\n  }\n}\n\nexport function getInternalDragOptions(dragConfig: DragConfig = {}): InternalDragOptions {\n  let { enabled, threshold, bounds, rubberband, initial, ...dragOptions } = dragConfig\n  let {\n    swipeVelocity = DEFAULT_SWIPE_VELOCITY,\n    swipeDistance = DEFAULT_SWIPE_DISTANCE,\n    delay = false,\n    filterTaps = false,\n    axis,\n    lockDirection,\n  } = dragOptions\n\n  if (threshold === void 0) {\n    threshold = Math.max(0, filterTaps ? 3 : 0, lockDirection || axis ? 1 : 0)\n  } else {\n    filterTaps = true\n  }\n\n  const internalCoordinatesOptions = getInternalCoordinatesOptions(\n    matchKeysFromObject({ enabled, threshold, bounds, rubberband, axis, lockDirection, initial }, dragConfig)\n  )\n\n  return {\n    ...internalCoordinatesOptions,\n    filterTaps: filterTaps || internalCoordinatesOptions.threshold[0] + internalCoordinatesOptions.threshold[1] > 0,\n    swipeVelocity: def.array(swipeVelocity) as Vector2,\n    swipeDistance: def.array(swipeDistance) as Vector2,\n    delay: typeof delay === 'number' ? delay : delay ? DEFAULT_DRAG_DELAY : 0,\n  }\n}\n","import { TouchEvent, WheelEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey, Vector2, WebKitGestureEvent } from '../types'\nimport { noop } from '../utils/utils'\nimport {\n  getGenericEventData,\n  getTwoTouchesEventData,\n  getWheelEventValues,\n  supportsGestureEvents,\n  getWebkitGestureEventValues,\n} from '../utils/event'\n\nexport default class PinchRecognizer extends DistanceAngleRecognizer<'pinch'> {\n  ingKey = 'pinching' as IngKey\n\n  constructor(controller: Controller, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  private pinchShouldStart = (event: UseGestureEvent) => {\n    const { touches } = getGenericEventData(event)\n    return this.enabled && touches === 2\n  }\n\n  onPinchStart = (event: UseGestureEvent<TouchEvent>) => {\n    if (!this.pinchShouldStart(event)) return\n\n    const { values, origin } = getTwoTouchesEventData(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      origin,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onPinchChange = (event: UseGestureEvent<TouchEvent>): void => {\n    const { canceled, timeStamp, _active } = this.state\n    if (canceled || !_active) return\n    const genericEventData = getGenericEventData(event)\n    if (genericEventData.touches !== 2 || event.timeStamp === timeStamp) return\n\n    this.updateSharedState(genericEventData)\n\n    const { values, origin } = getTwoTouchesEventData(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      origin,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onPinchEnd = (event: UseGestureEvent): void => {\n    if (!this.state.active) return\n    this.state._active = false\n    this.updateSharedState({ down: false, touches: 0 })\n\n    this.updateGestureState({\n      event,\n      ...this.getGenericPayload(event),\n      ...this.getMovement(this.state.values),\n    })\n    this.fireGestureHandler()\n  }\n\n  onCancel = (): void => {\n    this.state._active = false\n    this.updateGestureState({ canceled: true, cancel: noop })\n    this.updateSharedState({ down: false, touches: 0 })\n\n    requestAnimationFrame(() => this.fireGestureHandler())\n  }\n  /**\n   * PINCH WITH WEBKIT GESTURES\n   */\n\n  onGestureStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault()\n\n    const { values } = getWebkitGestureEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureChange = (event: WebKitGestureEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n\n    event.preventDefault()\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getWebkitGestureEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    event.preventDefault()\n    if (!this.state.active) return\n    this.state._active = false\n    this.updateSharedState({ down: false, touches: 0 })\n\n    this.updateGestureState({\n      event,\n      ...this.getGenericPayload(event),\n      ...this.getMovement(this.state.values),\n    })\n    this.fireGestureHandler()\n  }\n\n  updateTouchData = (event: UseGestureEvent<TouchEvent>): void => {\n    if (!this.enabled || event.touches.length !== 2 || !this.state._active) return\n    const { origin } = getTwoTouchesEventData(event)\n    this.state.origin = origin\n  }\n\n  /**\n   * PINCH WITH WHEEL\n   */\n  private wheelShouldRun = (event: UseGestureEvent<WheelEvent>) => {\n    return this.enabled && event.ctrlKey\n  }\n\n  private getWheelValuesFromEvent = (event: UseGestureEvent<WheelEvent>) => {\n    const {\n      values: [, delta_d],\n    } = getWheelEventValues(event)\n    const {\n      values: [prev_d, prev_a],\n    } = this.state\n    const d = prev_d - delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n\n    return {\n      values: [d, a] as Vector2,\n      origin: [event.clientX, event.clientY] as Vector2,\n      delta: [0, delta_d] as Vector2,\n    }\n  }\n\n  onWheel = (event: UseGestureEvent<WheelEvent>): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.clearTimeout()\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: UseGestureEvent<WheelEvent>): void => {\n    const { values, delta, origin } = this.getWheelValuesFromEvent(event)\n\n    if (!this.controller.config.eventOptions.passive) {\n      event.preventDefault()\n    } else if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        'To support zoom on trackpads, try using the `domTarget` option and `config.event.passive` set to `false`. This message will only appear in development mode.'\n      )\n    }\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      offset: values,\n      delta,\n      origin,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: UseGestureEvent<WheelEvent>): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values, origin, delta } = this.getWheelValuesFromEvent(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      origin,\n      delta,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState(this.getMovement(this.state.values))\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && supportsGestureEvents()) {\n      this.controller.addBindings('onGestureStart', this.onGestureStart)\n      this.controller.addBindings('onGestureChange', this.onGestureChange)\n      this.controller.addBindings(['onGestureEnd', 'onTouchCancel'], this.onGestureEnd)\n      this.controller.addBindings(['onTouchStart', 'onTouchMove'], this.updateTouchData)\n    } else {\n      this.controller.addBindings('onTouchStart', this.onPinchStart)\n      this.controller.addBindings('onTouchMove', this.onPinchChange)\n      this.controller.addBindings(['onTouchEnd', 'onTouchCancel'], this.onPinchEnd)\n\n      this.controller.addBindings('onWheel', this.onWheel)\n    }\n  }\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics } from '../utils/math'\nimport { Vector2, UseGestureEvent, PartialGestureState, DistanceAngleKey, GestureState } from '../types'\n\n/**\n * @private\n * Abstract class for distance/angle-based gesture recongizers\n * @abstract\n * @class DistanceAngleRecognizer\n * @extends {Recognizer<T>}\n * @template T\n */\nexport default abstract class DistanceAngleRecognizer<T extends DistanceAngleKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into acount)\n   */\n  protected getInternalMovement([d, a]: [number, number?], state: GestureState<T>): Vector2 {\n    const { values: da, turns, initial } = state\n\n    // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n    a = a !== void 0 ? a : da[1]\n\n    let delta_a = a - da[1]\n\n    /**\n     * The angle value might jump from 179deg to -179deg when we actually want to\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\n     * is supsiciously high (ie > 270deg) and increase the `turns` value\n     */\n    const newTurns = Math.abs(delta_a) > 270 ? turns + Math.sign(delta_a) : turns\n\n    // we update the angle difference to its corrected value\n\n    const movement_d = d - initial[0]\n    const movement_a = a - 360 * newTurns - initial[1]\n    return [movement_d, movement_a]\n  }\n\n  getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T> {\n    const { timeStamp, initial } = this.state\n\n    const movementDetection = this.getMovement(values, this.state)\n    const { delta, movement } = movementDetection\n\n    const turns = (values[1] - movement![1] - initial[1]) / 360\n\n    const delta_t = event.timeStamp - timeStamp!\n    const kinematics = calculateAllKinematics(movement!, delta!, delta_t)\n\n    return {\n      values,\n      delta,\n      turns,\n      ...movementDetection,\n      ...kinematics,\n    }\n  }\n\n  protected mapStateValues(state: GestureState<T>): PartialGestureState<T> {\n    return { da: state.values, vdva: state.velocities } as PartialGestureState<T>\n  }\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getWheelEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateDistance, calculateDirection } from '../utils/math'\n\nexport default class WheelRecognizer extends CoordinatesRecognizer<'wheel'> {\n  ingKey = 'wheeling' as IngKey\n  debounced = true\n\n  constructor(controller: Controller, args: any[]) {\n    super('wheel', controller, args)\n  }\n\n  private wheelShouldRun = (event: UseGestureEvent<WheelEvent>) => {\n    if (event.ctrlKey && 'pinch' in this.controller.handlers) return false\n    return this.enabled\n  }\n\n  private getValuesFromEvent = (event: UseGestureEvent<WheelEvent>) => {\n    const { values: prevValues } = this.state\n    const { values } = getWheelEventValues(event)\n    return { values: addV(values, prevValues) }\n  }\n\n  onWheel = (event: UseGestureEvent<WheelEvent>): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.clearTimeout()\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: UseGestureEvent<WheelEvent>): void => {\n    const { values } = this.getValuesFromEvent(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    const movementDetection = this.getMovement(values, startState)\n    const delta = movementDetection.delta!\n\n    this.updateGestureState({\n      ...startState,\n      ...movementDetection,\n      distance: calculateDistance(delta),\n      direction: calculateDirection(delta),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: UseGestureEvent<WheelEvent>): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = this.getValuesFromEvent(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    this.controller.addBindings('onWheel', this.onWheel)\n  }\n}\n","import {} from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getGenericEventData, getPointerEventValues } from '../utils/event'\n\nexport default class MoveRecognizer extends CoordinatesRecognizer<'move'> {\n  ingKey = 'moving' as IngKey\n  debounced = true\n\n  constructor(controller: Controller, args: any[]) {\n    super('move', controller, args)\n  }\n\n  private moveShouldRun = () => {\n    return this.enabled\n  }\n\n  onMove = (event: UseGestureEvent): void => {\n    if (!this.moveShouldRun()) return\n    this.clearTimeout()\n    this.setTimeout(this.onMoveEnd)\n\n    if (!this.state._active) this.onMoveStart(event)\n    else this.onMoveChange(event)\n  }\n\n  onMoveStart = (event: UseGestureEvent): void => {\n    const { values } = getPointerEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveChange = (event: UseGestureEvent): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getPointerEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveEnd = (): void => {\n    this.state._active = false\n\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  onPointerEnter = (event: UseGestureEvent): void => {\n    this.controller.state.shared.hovering = true\n    if (!this.controller.config.enabled) return\n\n    if (this.controller.config.hover!.enabled) {\n      const { values } = getPointerEventValues(event)\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...this.getGenericPayload(event, true),\n        values,\n        active: true,\n        hovering: true,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n\n    if ('move' in this.controller.handlers) this.onMoveStart(event)\n  }\n\n  onPointerLeave = (event: UseGestureEvent): void => {\n    this.controller.state.shared.hovering = false\n    if ('move' in this.controller.handlers) this.onMoveEnd()\n\n    if (this.controller.config.hover!.enabled) {\n      const { values } = getPointerEventValues(event)\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...this.getGenericPayload(event),\n        values,\n        active: false,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n  }\n\n  addBindings(): void {\n    if (this.controller.config.pointer) {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onPointerMove', this.onMove)\n      }\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onPointerEnter', this.onPointerEnter)\n        this.controller.addBindings('onPointerLeave', this.onPointerLeave)\n      }\n    } else {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onMouseMove', this.onMove)\n      }\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onMouseEnter', this.onPointerEnter)\n        this.controller.addBindings('onMouseLeave', this.onPointerLeave)\n      }\n    }\n  }\n}\n","import {} from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getGenericEventData, getScrollEventValues } from '../utils/event'\nimport { calculateDistance, calculateDirection } from '../utils/math'\n\nexport default class ScrollRecognizer extends CoordinatesRecognizer<'scroll'> {\n  ingKey = 'scrolling' as IngKey\n  debounced = true\n\n  constructor(controller: Controller, args: any[]) {\n    super('scroll', controller, args)\n  }\n\n  private scrollShouldRun = () => {\n    return this.enabled\n  }\n\n  onScroll = (event: UseGestureEvent): void => {\n    if (!this.scrollShouldRun()) return\n    this.clearTimeout()\n    this.setTimeout(this.onScrollEnd)\n\n    if (!this.state._active) this.onScrollStart(event)\n    else this.onScrollChange(event)\n  }\n\n  onScrollStart = (event: UseGestureEvent): void => {\n    const { values } = getScrollEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    const movementDetection = this.getMovement(values, startState)\n    const delta = movementDetection.delta!\n\n    this.updateGestureState({\n      ...startState,\n      ...movementDetection,\n      distance: calculateDistance(delta),\n      direction: calculateDirection(delta),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onScrollChange = (event: UseGestureEvent): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getScrollEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onScrollEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    this.controller.addBindings('onScroll', this.onScroll)\n  }\n}\n","import React from 'react'\nimport useRecognizers from './useRecognizers'\nimport DragRecognizer from '../recognizers/DragRecognizer'\nimport WheelRecognizer from '../recognizers/WheelRecognizer'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport PinchRecognizer from '../recognizers/PinchRecognizer'\nimport ScrollRecognizer from '../recognizers/ScrollRecognizer'\nimport {\n  getInternalGenericOptions,\n  getInternalDragOptions,\n  getInternalCoordinatesOptions,\n  getInternalDistanceAngleOptions,\n} from '../utils/config'\nimport {\n  InternalConfig,\n  HandlerKey,\n  UserHandlersPartial,\n  InternalHandlers,\n  UserHandlers,\n  RecognizerClasses,\n  UseGestureConfig,\n  HookReturnType,\n} from '../types'\n\n/**\n * @public\n *\n * The most complete gesture hook, allowing support for multiple gestures.\n *\n * @param {UserHandlersPartial} handlers - an object with on[Gesture] keys containg gesture handlers\n * @param {UseGestureConfig} [config={}] - the full config object\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useGesture<Config extends UseGestureConfig>(\n  handlers: UserHandlersPartial,\n  config: UseGestureConfig = {}\n): (...args: any[]) => HookReturnType<Config> {\n  /**\n   * If handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\n   * actions will include 'onDrag' and 'onMove.\n   */\n  const [actions] = React.useState(() => new Set(Object.keys(handlers).map(k => k.replace(/End|Start/, ''))))\n\n  /**\n   * Here we compute the derived internal config based on the provided config object.\n   * We decompose the config into its generic and gesture options and compute each.\n   * TODO: this is currently done on every render!\n   */\n  const { drag, wheel, move, scroll, pinch, hover, ...restConfig } = config\n\n  const mergedConfig: InternalConfig = getInternalGenericOptions(restConfig)\n\n  const classes: RecognizerClasses = []\n  const internalHandlers: Partial<InternalHandlers> = {}\n\n  // will hold reference to native handlers such as onClick, onMouseDown, etc.\n  const _nativeHandlers = { ...handlers }\n\n  if (actions.has('onDrag')) {\n    classes.push(DragRecognizer)\n    internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag', _nativeHandlers)\n    mergedConfig.drag = getInternalDragOptions(drag)\n  }\n  if (actions.has('onWheel')) {\n    classes.push(WheelRecognizer)\n    internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel', _nativeHandlers)\n    mergedConfig.wheel = getInternalCoordinatesOptions(wheel)\n  }\n  if (actions.has('onScroll')) {\n    classes.push(ScrollRecognizer)\n    internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll', _nativeHandlers)\n    mergedConfig.scroll = getInternalCoordinatesOptions(scroll)\n  }\n  if (actions.has('onMove')) {\n    classes.push(MoveRecognizer)\n    internalHandlers.move = includeStartEndHandlers(handlers, 'onMove', _nativeHandlers)\n    mergedConfig.move = getInternalCoordinatesOptions(move)\n  }\n  if (actions.has('onPinch')) {\n    classes.push(PinchRecognizer)\n    internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch', _nativeHandlers)\n    mergedConfig.pinch = getInternalDistanceAngleOptions(pinch)\n  }\n  if (actions.has('onHover')) {\n    if (!actions.has('onMove')) classes.push(MoveRecognizer)\n    internalHandlers.hover = handlers.onHover\n    mergedConfig.hover = { enabled: true, ...hover }\n    delete _nativeHandlers.onHover\n  }\n\n  return useRecognizers<Config>(internalHandlers, classes, mergedConfig, _nativeHandlers)\n}\n/**\n * @private\n *\n * This utility function will integrate start and end handlers into the regular\n * handler function by using first and last conditions.\n *\n * @param {UserHandlersPartial} handlers - the handlers function object\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\n * @returns\n */\nfunction includeStartEndHandlers(\n  handlers: UserHandlersPartial,\n  handlerKey: HandlerKey,\n  _nativeHandlers: UserHandlersPartial\n) {\n  const startKey = (handlerKey + 'Start') as keyof UserHandlers\n  const endKey = (handlerKey + 'End') as keyof UserHandlers\n\n  delete _nativeHandlers[handlerKey]\n  delete _nativeHandlers[startKey]\n  delete _nativeHandlers[endKey]\n\n  const fn = (state: any) => {\n    let memo: any = undefined\n    if (state.first && startKey in handlers) handlers[startKey]!(state)\n    if (handlerKey in handlers) memo = handlers[handlerKey]!(state)\n    if (state.last && endKey in handlers) handlers[endKey]!(state)\n    return memo\n  }\n  return fn\n}\n","import useRecognizers from './useRecognizers'\nimport DragRecognizer from '../recognizers/DragRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseDragConfig } from '../types'\nimport { getInternalGenericOptions, getInternalDragOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Drag hook.\n *\n * @param {Handler<'drag'>} handler - the function fired every time the drag gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and drag options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useDrag<Config extends UseDragConfig>(\n  handler: Handler<'drag'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...drag } = config as UseDragConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    drag: getInternalDragOptions(drag),\n  }\n\n  return useRecognizers<Config>({ drag: handler }, [DragRecognizer], mergedConfig)\n}\n","import useRecognizers from './useRecognizers'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseHoverConfig } from '../types'\nimport { getInternalGenericOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Hover hook.\n *\n * @param {Handler<'hover'>} handler - the function fired every time the hover gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and hover options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useHover<Config extends UseHoverConfig>(\n  handler: Handler<'hover'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...hover } = config as UseHoverConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    hover: { enabled: true, ...hover },\n  }\n\n  return useRecognizers<Config>({ hover: handler }, [MoveRecognizer], mergedConfig)\n}\n","import useRecognizers from './useRecognizers'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseMoveConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Move hook.\n *\n * @param {Handler<'move'>} handler - the function fired every time the move gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and move options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useMove<Config extends UseMoveConfig>(\n  handler: Handler<'move'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...move } = config as UseMoveConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    move: getInternalCoordinatesOptions(move),\n  }\n\n  return useRecognizers<Config>({ move: handler }, [MoveRecognizer], mergedConfig)\n}\n","import useRecognizers from './useRecognizers'\nimport PinchRecognizer from '../recognizers/PinchRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UsePinchConfig } from '../types'\nimport { getInternalGenericOptions, getInternalDistanceAngleOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Pinch hook.\n *\n * @param {Handler<'pinch'>} handler - the function fired every time the pinch gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and pinch options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function usePinch<Config extends UsePinchConfig>(\n  handler: Handler<'pinch'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...pinch } = config as UsePinchConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    pinch: getInternalDistanceAngleOptions(pinch),\n  }\n\n  return useRecognizers<Config>({ pinch: handler }, [PinchRecognizer], mergedConfig)\n}\n","import useRecognizers from './useRecognizers'\nimport ScrollRecognizer from '../recognizers/ScrollRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseScrollConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Scroll hook.\n *\n * @param {Handler<'scroll'>} handler - the function fired every time the scroll gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and scroll options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useScroll<Config extends UseScrollConfig>(\n  handler: Handler<'scroll'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...scroll } = config as UseScrollConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    scroll: getInternalCoordinatesOptions(scroll),\n  }\n\n  return useRecognizers<Config>({ scroll: handler }, [ScrollRecognizer], mergedConfig)\n}\n","import useRecognizers from './useRecognizers'\nimport WheelRecognizer from '../recognizers/WheelRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseWheelConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Wheel hook.\n *\n * @param {Handler<'wheel'>} handler - the function fired every time the wheel gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and wheel options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useWheel<Config extends UseWheelConfig>(\n  handler: Handler<'wheel'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...wheel } = config as UseWheelConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    wheel: getInternalCoordinatesOptions(wheel),\n  }\n\n  return useRecognizers<Config>({ wheel: handler }, [WheelRecognizer], mergedConfig)\n}\n"],"names":["addV","v1","v2","map","v","i","subV","calculateVelocity","delta","delta_t","len","Math","hypot","calculateVelocities","Array","length","fill","calculateDistance","movement","calculateDirection","calculateAllKinematics","velocities","velocity","distance","direction","getIntentionalDisplacement","threshold","abs","sign","rubberband","dimension","constant","Infinity","pow","rubberband2","rubberbandIfOutOfBounds","position","min","max","value","minMax","noop","chainFns","fns","args","forEach","fn","def","isArray","defaultIfUndefined","matchKeysFromObject","obj","matchingObject","o","Object","entries","key","valueFn","getInitialState","initialCommon","_active","_blocked","_intentional","_movement","_initial","_lastEventType","undefined","event","values","offset","lastOffset","initial","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","initialCoordinates","axis","xy","vxvy","shared","hovering","scrolling","wheeling","dragging","moving","pinching","touches","buttons","down","shiftKey","altKey","metaKey","ctrlKey","drag","_isTap","_delayedEvent","tap","swipe","pinch","da","vdva","origin","turns","wheel","move","scroll","setListeners","add","el","listeners","options","action","addListeners","removeListeners","getTouchEvents","changedTouches","getGenericEventData","touchEvents","getModifierKeys","getScrollEventValues","currentTarget","scrollX","scrollLeft","scrollY","scrollTop","getWheelEventValues","deltaX","deltaY","getPointerEventValues","clientX","clientY","getWebkitGestureEventValues","scale","rotation","getTwoTouchesEventData","dx","dy","atan2","PI","Controller","_this","resetBindings","timeouts","clearTimeout","keys","windowListeners","stateKey","removeWindowListeners","bindings","domTarget","getDomTarget","domListeners","config","eventOptions","current","window","target","push","substr","toLowerCase","eventNames","eventName","captureString","fnsArray","addDomTargetListeners","clean","getBindings","useRecognizers","handlers","classes","nativeHandlers","controller","React","useMemo","nativeRefs","bind","RecognizerClass","addBindings","getBind","useEffect","Recognizer","callback","ms","setTimeout","addWindowListeners","state","vector","bounds","forceFlag","debounced","ingKey","mapStateValues","newMemo","handler","updateSharedState","sharedState","assign","this","updateGestureState","gestureState","getGenericPayload","isStartEvent","type","checkIntentionality","_state","getMovement","t0","t1","intentional","prevMovement","i0","i1","getInternalMovement","_m0","_m1","intentionalityCheck","_i0","_i1","_rubberband","enabled","CoordinatesRecognizer","absX","absY","configAxis","lockDirection","getKinematics","movementDetection","DragRecognizer","indexOf","pointer","isEventTypeTouch","pointerId","setPointerCapture","releasePointerCapture","isTouch","onDragChange","onDragEnd","dragShouldStart","setPointers","delay","persist","startDrag","genericEventData","kinematics","onCancel","fireGestureHandler","vx","vy","mx","my","ix","iy","endState","swipeVelocity","svx","svy","swipeDistance","sx","sy","filterTaps","removePointers","requestAnimationFrame","startState","getStartGestureState","_this2","onDragStart","defaultWindow","defaultCoordinatesOptions","getInternalGenericOptions","passive","capture","getInternalGestureOptions","gestureConfig","getInternalCoordinatesOptions","coordinatesConfig","internalOptions","boundsArray","left","right","top","bottom","getInternalDistanceAngleOptions","distanceAngleConfig","distanceBounds","angleBounds","getInternalDragOptions","dragConfig","dragOptions","internalCoordinatesOptions","PinchRecognizer","pinchShouldStart","preventDefault","delta_d","prev_a","wheelShouldRun","onWheelEnd","onWheelChange","onWheelStart","getWheelValuesFromEvent","GestureEvent","e","supportsGestureEvents","onGestureStart","onGestureChange","onGestureEnd","updateTouchData","onPinchStart","onPinchChange","onPinchEnd","onWheel","d","a","delta_a","newTurns","WheelRecognizer","prevValues","getValuesFromEvent","MoveRecognizer","moveShouldRun","onMoveEnd","onMoveChange","onMoveStart","hover","onMove","onPointerEnter","onPointerLeave","ScrollRecognizer","scrollShouldRun","onScrollEnd","onScrollChange","onScrollStart","onScroll","includeStartEndHandlers","handlerKey","_nativeHandlers","startKey","endKey","mergedConfig","actions","useState","Set","k","replace","internalHandlers","has","onHover"],"mappings":"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"}