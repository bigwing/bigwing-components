import * as React from "react";
import { SealedInitialState } from "reakit-utils/useSealedState";
import { unstable_IdState, unstable_IdActions, unstable_IdInitialState, unstable_IdStateReturn } from "../Id/IdState";
import { Item, Group, Orientation } from "./__utils/types";
export declare type CompositeState = unstable_IdState & {
    /**
     * If enabled, the composite element will act as an
     * [aria-activedescendant](https://www.w3.org/TR/wai-aria-practices-1.1/#kbd_focus_activedescendant)
     * container instead of
     * [roving tabindex](https://www.w3.org/TR/wai-aria-practices/#kbd_roving_tabindex).
     * DOM focus will remain on the composite while its items receive virtual focus.
     */
    unstable_virtual: boolean;
    /**
     * Determines how `next` and `previous` functions will behave. If `rtl` is
     * set to `true`, they will be inverted. You still need to set `dir="rtl"` on
     * HTML/CSS.
     */
    rtl: boolean;
    /**
     * Defines the orientation of the composite widget. If the composite has a
     * single row or column (one-dimensional), the `orientation` value determines
     * which arrow keys can be used to move focus:
     *   - `undefined`: all arrow keys work.
     *   - `horizontal`: only left and right arrow keys work.
     *   - `vertical`: only up and down arrow keys work.
     *
     * It doesn't have any effect on two-dimensional composites.
     */
    orientation?: Orientation;
    /**
     * Lists all the composite items with their `id`, DOM `ref`, `disabled` state
     * and `groupId` if any. This state is automatically updated when
     * `registerItem` and `unregisterItem` are called.
     */
    items: Item[];
    /**
     * Lists all the composite groups with their `id` and DOM `ref`. This state
     * is automatically updated when `registerGroup` and `unregisterGroup` are
     * called.
     */
    groups: Group[];
    /**
     * The current focused item `id`.
     *   - `undefined` will automatically focus the first enabled composite item.
     *   - `null` will focus the composite container and users will be able to
     * navigate out of it using arrow keys.
     *   - If `currentId` is initially set to `null`, the composite element
     * itself will have focus and users will be able to navigate to it using
     * arrow keys.
     */
    currentId?: string | null;
    /**
     * On one-dimensional composites:
     *   - `true` loops from the last item to the first item and vice-versa.
     *   - `horizontal` loops only if `orientation` is `horizontal` or not set.
     *   - `vertical` loops only if `orientation` is `vertical` or not set.
     *   - If `currentId` is initially set to `null`, the composite element will
     * be focused in between the last and first items.
     *
     * On two-dimensional composites:
     *   - `true` loops from the last row/column item to the first item in the
     * same row/column and vice-versa. If it's the last item in the last row, it
     * moves to the first item in the first row and vice-versa.
     *   - `horizontal` loops only from the last row item to the first item in
     * the same row.
     *   - `vertical` loops only from the last column item to the first item in
     * the column row.
     *   - If `currentId` is initially set to `null`, vertical loop will have no
     * effect as moving down from the last row or up from the first row will
     * focus the composite element.
     *   - If `wrap` matches the value of `loop`, it'll wrap between the last
     * item in the last row or column and the first item in the first row or
     * column and vice-versa.
     */
    loop: boolean | Orientation;
    /**
     * If enabled, moving to the next item from the last one in a row or column
     * will focus the first item in the next row or column and vice-versa.
     *   - `true` wraps between rows and columns.
     *   - `horizontal` wraps only between rows.
     *   - `vertical` wraps only between columns.
     *   - If `loop` matches the value of `wrap`, it'll wrap between the last
     * item in the last row or column and the first item in the first row or
     * column and vice-versa.
     */
    wrap: boolean | Orientation;
    /**
     * Stores the number of moves that have been performed by calling `move`,
     * `next`, `previous`, `up`, `down`, `first` or `last`.
     */
    unstable_moves: number;
    /**
     * @private
     */
    unstable_angular: boolean;
    /**
     * @private
     */
    unstable_hasActiveWidget: boolean;
};
export declare type CompositeActions = unstable_IdActions & {
    /**
     * Registers a composite item.
     */
    registerItem: (item: Item) => void;
    /**
     * Unregisters a composite item.
     */
    unregisterItem: (id: string) => void;
    /**
     * Registers a composite group.
     */
    registerGroup: (group: Group) => void;
    /**
     * Unregisters a composite group.
     */
    unregisterGroup: (id: string) => void;
    /**
     * Moves focus to a given item ID.
     */
    move: (id: string | null) => void;
    /**
     * Moves focus to the next item.
     */
    next: (unstable_allTheWay?: boolean) => void;
    /**
     * Moves focus to the previous item.
     */
    previous: (unstable_allTheWay?: boolean) => void;
    /**
     * Moves focus to the item above.
     */
    up: (unstable_allTheWay?: boolean) => void;
    /**
     * Moves focus to the item below.
     */
    down: (unstable_allTheWay?: boolean) => void;
    /**
     * Moves focus to the first item.
     */
    first: () => void;
    /**
     * Moves focus to the last item.
     */
    last: () => void;
    /**
     * Sorts the composite items state. This is especially useful after modifying
     * the composite items order in the DOM.
     */
    sort: () => void;
    /**
     * Sets `virtual`.
     */
    unstable_setVirtual: React.Dispatch<React.SetStateAction<CompositeState["unstable_virtual"]>>;
    /**
     * Sets `rtl`.
     */
    setRTL: React.Dispatch<React.SetStateAction<CompositeState["rtl"]>>;
    /**
     * Sets `orientation`.
     */
    setOrientation: React.Dispatch<React.SetStateAction<CompositeState["orientation"]>>;
    /**
     * Sets `currentId`.
     */
    setCurrentId: React.Dispatch<React.SetStateAction<CompositeState["currentId"]>>;
    /**
     * Sets `loop`.
     */
    setLoop: React.Dispatch<React.SetStateAction<CompositeState["loop"]>>;
    /**
     * Sets `wrap`.
     */
    setWrap: React.Dispatch<React.SetStateAction<CompositeState["wrap"]>>;
    /**
     * Resets to initial state.
     */
    reset: () => void;
    /**
     * Sets `hasActiveWidget`.
     * @private
     */
    unstable_setHasActiveWidget: React.Dispatch<React.SetStateAction<CompositeState["unstable_hasActiveWidget"]>>;
};
export declare type CompositeInitialState = unstable_IdInitialState & Partial<Pick<CompositeState, "unstable_virtual" | "rtl" | "orientation" | "currentId" | "loop" | "wrap" | "unstable_angular">>;
export declare type CompositeStateReturn = unstable_IdStateReturn & CompositeState & CompositeActions;
export declare function useCompositeState(initialState?: SealedInitialState<CompositeInitialState>): CompositeStateReturn;
